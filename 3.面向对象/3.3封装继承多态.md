## 继承
### 原型链继承
问题：
- 原型的构造函数指向父类，原型实际变成另一个类型的实例，父类中的属性顺理成章变成现在的原型属性。父类中的属性会被不同实例共享。
- 创建子类型的实例时，不能向父类型中传递参数。没办法在不影响所有对象实例的情况下给父类传递参数。
```javascript
function Supper() {
    this.name = "Supper";
    this.arrColor = [];
}
Supper.prototype.getSupperName = function() {
    return this.name;
}
function Child() {
    this.name = "child";
    this.age = 10;
}
Child.prototype = new Supper();

// 添加方法或重写要放在替换原型之后
Child.prototype.getChildName = function() {
    return this.name + this.age;
};
Child.prototype.getSupperName = function() {
    return this.age;
}

var c = new Child();
console.log(c.__proto__);
console.log(Child.prototype);
console.log(c.getChildName());

console.log(c instanceof Object); // true
console.log(c instanceof Supper); // true
console.log(c instanceof Child); // true

// 只要原型链中出现过的都是实力的原型
console.log(Object.prototype.isPrototypeOf(c)); // true
console.log(Supper.prototype.isPrototypeOf(c)); // true
console.log(Child.prototype.isPrototypeOf(c)); // true

// 父类中的属性会被不同实例共享。
Supper.prototype.setColor = function (color) {
    this.arrColor.push(color);
};
c.setColor('red');
var b = new Child();
console.log(b.arrColor); // ['red']
```
此时Child的实例的constructor是指向的Supper.因此Child的prototype重写的原因。变量搜索如下：
- 搜索Child的实例对象
- 搜索Child的prototype
- 搜索Supper的prototype
![](/assets/extend.png)
下面时加上object继承的图解：
![](/assets/allExtend.png)

### 借用构造函数
- 借用构造函数，是利用call或apply在子构造函数中进行调用父类。这样就会有自己的父类副本，不父类中的值不会公用。问题：所有子类需要的方法都需要在构造函数中创建，达不到复用。
- 借用构造函数能够传参数
```javascript
function Supper(name) {
    this.name = name;
}
function Child(name, age) {
    Supper.call(this, name)
    this.age = age;
}

```
### 组合式继承
```javascript
function Supper(name) {
    this.name = name;
    this.arrayColor = [];
}
Supper.prototype.saySpperName = function() {
    console.log(this.name);
};
function Child(name, age) {
    Supper.call(this, name)
    this.age = age;
}
Child.prototype = new Supper();
Child.prototype.constructor = Child;
Child.prototype.sayChildName = function() {
    console.log("child:" + this.name);
}
Child.prototype.pushColor = function(color) {
    this.arrayColor.push(color);
}

var c1 = new Child('yezi', 20);
c1.push('red');
var c2 = new Child('yezi', 20);
c2.push('yellow');
console.log(c1.arrayColor); // ['red']
console.log(c2.arrayColor); // ['yellow']
```
### 原型式继承
想继承已经有的对象，并且不需要创建自定义类型。
- Child方法会继承Super所有的内容
- Child原型指向Supper的对象
```javascript
function extend(o) {
    function Child() {
    }
    Child.prototype = o; 
    // 在这里定义的内容无法在外部访问
    <!--Child.prototype.setColor = function(color) {
        this.arrayColor.push(color);
    }-->
    return new Child();
}
function Supper() {
    this.name = "supper";
    this.arrayColor = [];
}
var child = extend(new Supper());
  
// 等同于 Es5的Object.create
var c1 = Object.create(new Supper());
```