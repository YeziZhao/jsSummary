## 变量创建

## 原始类型变量与普通类型变量区别

- 内存存放  
    原始类型在heap内存中定义变量，并将值复制给变变量，而引用类型在heap内存中定义变量，并在stack内存中定义了值，再讲该值得引用赋给heap内存中的变量。如下图：
    ![](/assets/heap.png)    

- 动态属性
    原始类型是不能添加动态属性的，而引用类型可以添加属性，方法。
    ```
    var a = "originstr";
    a.length = 10; // 会创建一个String包装类的临时对象，执行完毕销毁临时对象
    console.log(a.length); // undefined 

    var b = new Object();
    b.name = "yeziTesting";
    console.log(b.name); // yeziTesting
    ```
- 复制变量值
    - 原始变量复制：是在heap中新创建一个变量，将值copy一份给新创建的变量。
    - 引用变量复制：在heap中新创建一个变量，将地址引用copy一份给新创建的变量。因此两个变量指向的内容实际是同一个。
   ![](/assets/valueCopy.jpg)
   ![](/assets/refCopy.jpg)

- 参数传递
    通常我们在函数中，会从外传递不同类型的参数给调用函数。函数有自己的作用域，而函数的参数即使函数自己的局部变量，函数局部变量 = 参数拷贝。而参数拷贝的是在heap内存中变量存放的值。如下：
    1. 原始类型传递
    ```
    function originType(count) {
        return count + 1;
    }
    var count = 10;
    console.log(count); // 11
    ```

    2. 引用类型传递
    以下举了2个函数例子：
    - refType中的局部变量refAddress 复制了外部传入的refAddress的地址。由此两个值指向同一个地址。修改了后，外部同样更改。
    - refType2中，复制了外部传入的refAddress的地址。但是又自己new了个对象，因此它没有影响到外部的值。
    ```
    function refType(refAddress) {
        refAddress.name = "update";
    }
    var refAddress = {name:"origin"};
    refType(refAddress);
    console.log(refAddress); // update

    function refType2(refAddress) {
       refAddress = new Object();
       refAddress.name = "mySelf";
    }
    refType2(refAddress);
    console.log(refAddress); // update
    ```
- 类型检测
    原始类型的检测可以使用typeof直接检测出来，如下：
    ```
    typeof true; // boolean
    typeof "string"; // string
    typeof 10; // number
    typeof undefined; // undefined
    typeof null; // object
    ```

    引用类型的检测使用typeof会都返回object.因此无法具体区分出来是哪个。可以使用instanceof进行判断。
    ```
    var a = new String(10);
    var b = "10";
    console.log(a instanceof String); // true
    conosole.log(b instanceof String); // false
    ```

## 作用域


