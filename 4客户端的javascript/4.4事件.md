# 事件流
如果你单击了某个按钮，单击事件不仅仅发生在按钮上。在单击按钮的同时，你也单击了按钮的容器元素，甚至也单击了整个页面。IE的事件流是事件冒泡流。Netscape Communicator的事件流是事件捕获流。
## 事件冒泡
IE的事件流是时间冒泡（event bubbling）.当事情开始时由最具体的元素(文档中嵌套层次最深的节点)接收。然后逐级向上传播到不具体的文档。
```html
<!DOCTYPE html>
<html>
    <body>
        <div>Click me</div>
    </body>
</html>
```
如果单机了<div>元素，则click事件传入顺序： div => body => html => document.每一级都会发生直到传播到document对象上。
## 事件捕获
netscape Communicator提出另一种事件流：事件捕获（event capturing)。先从不具体的节点接收到事件，最具体的节点最后接收到事件。事件捕获意义：在事件到达预定目标前捕获它。上面的例子单机div后触发的click事件：document => html => body => div。
事件捕获使用的比较少，一般使用事件冒泡。

## DOM事件流
"DOM2级事件"规定的时间流包含三个阶段：
- 捕获阶段： 为截获事件提供机会。捕获是从下图 1-3 步骤，到达div之前停止。
- 处于目标阶段：到达div
- 时间冒泡阶段: 事件发生到div上，并且事件又传播到文档。4-7步骤
![](/assets/event1.png)<br>

# 事件处理程序
事件就是用户或浏览器的某种动作，例如click, load, mouseover是事件名字.而响应某个事件就是事件处理程序。事件处理程序由`on`开头。因此click事件处理程序为onclick,load事件处理程序为onLoad。
## HTML事件处理程序
某个元素支持某种事件，使用一个与相应事件的事件处理程序同名的HTML特性来指定。
- event: 直接访问时间对象。不需要自己定义它，也不用从函数参数列表中读取。
- this: 等于时间目标元素，这里是input节点HTMLElement
```html
<input type="button" value="click me" onClick="alert(event.type + this.value);">

<!-- 拓展作用域 -->
<input type="button" value="click me" onClick="function() {
    with(this.form) {
        with(this) {

        }
    }
}">

<input type="button" value="click me" onClick="try {alert(event.type + this.value);} catch(e) {}">
```
缺点：
- 当html元素加载完毕，但是事件还未具备执行条件，点击按钮抛异常。使用异常捕获处理。
- HTML代码合js代码紧密耦合。
- 这样扩展事件处理程序的作用域链在不同浏览器中会导致不同结果。不同 JavaScript 引擎遵循的标识符解析规则略有差异，很可能会在访问非限定对象成员时出错。

## DOM0级事件处理程序
每个元素（包括window，document）都有自己的事件处理程序属性，通常属性都是小写。例如onclick.将这种属性的值设置为一个函数，就可以指定事件处理程序了。
- 在代码运行前，不会为元素指定事件处理程序。如果运行位于加载页面元素之后，可能有段时间点击没反应
- this: 事件处理程序被认为是元素方法，this指向当前元素
```javascript
var btn = document.getElementById('btn');
btn.onclick = function() {
    alert(this.id);
};
```
这种方式添加的处理程序会再事件流的冒泡阶段被处理。可以删除DOM0级指定的事件处理程序。
```javascript
btn.onclick = null;
```

## DOM2级事件处理程序
DOM2级事件处理程序定义了两个方法，用于处理指定和删除事件处理程序。有三个参数（要处理的事件名， 事件处理程序的函数， true捕获阶段调用事件处理程序false冒泡阶段调用事件处理程序[默认false]）。
- addEventListener(eventName, function, booleanValue)
- removeEventListener()(eventName, function, booleanValue)
```javascript
var btn = document.getElementById('btn');
btn.addEventListener('click', function() {
    alert(this.id);
});

btn.addEventListener('click', function() {
    console.log(this.value);
}, true);
```
上面添加了两个事件，会按照添加它们的顺序触发。通过addEventListener添加的时间，必须使用removeEventListener移除。匿名函数无法删除。
```javascript
// 没用
btn.removeEventListener('click', function() {
    alert(this.id);
});

var btn = document.getElementById('btn');
var handle = function() {
    alert(this.id);
};
btn.addEventListener('click', handle);
btn.removeEventListener('click', handle);
```
大多数情况下都是讲时间处理程序添加到事件流的冒泡阶段，最大限度兼容各种浏览器。如果不是特别需要，不建议在事件捕获阶段注册事件处理程序。

## IE事件处理程序
IE实现类似DOM中类似的两个方法，参数（事件处理程序名称，事件处理程序函数）。IE8及以前只支持事件冒泡，因此默认添加到事件冒泡阶段。
- attachEvent(eventName, function)
- detachEvent(eventName, function)
IE操作与DOM不一样的地方：
- 添加处理事件名称不一样
- 处理第一个参数，添加的与DOM事件处理程序参数不一样，IE是`onclick`.DOM是`click`.
- 事件处理程序作用域：DOM0级别程序会在其所属元素的作用域内运行。attachEvent会事件处理程序会在全局作用域中运行。this是window
- 添加事件与执行事件顺序不一致，最后添加的先运行。下面先'hello,handle2',然后打印出'true'
```javascript
var btn = document.getElementById('btn');
var handle = function() {
    console.log(this == window);  
};
var handle2 = function() {
    console.log('hello, handle2');
};
btn.attachEvent('onclick', handle);
btn.detachEvent('onclick', handle);
```
## 跨浏览器处理
这种方式只能说添加和移除事件功能成功，但是在函数内部调用this，IE是window,而其他的则是元素自身。
```javascript
var eventUtil = {
    addEvent: function(el, eventName, eventFunc) {
        if (el.addEventListener) {
            el.addEventListener(eventName, eventFunc);
        } else if(el.attachEvent) {
            el.attachEvent('on' + eventName, eventFunc);
        } else {
            el['on' + eventName] = eventFunc;
        }
    },
    removeEvent: function(el, eventName, eventFunc) {
        if (el.addEventLisremoveEventListenertener) {
            el.removeEventListener(eventName, eventFunc);
        } else if(el.detachEvent) {
            el.detachEvent('on' + eventName, eventFunc);
        } else {
            el['on' + eventName] = null;
        }
    },
};
```
# 事件对象
在触发DOM上的某个事件时，会产生一个事件对象event.这个对象包含事件的有关信息。例如鼠标事件会有鼠标位置信息，键盘操作事件会有按下的键有关信息。
## DOM中的事件对象
兼容DOM的浏览器会将一个event对象传入事件处理程序中。无论是DOM0还是DOM2.
```javascript
bar btn = document.getElementById('btn');
// DOM0
btn.onclick = function(event) {
    console.log(event.type); // click
};

// DOM2
btn.addEventListener('click', function(event) {
    console.log(event.type); // click
});
```
通过HTML特性制定的事件处理程序也会有event对象。
```html
<input type="button" value="click me" onclick="alert(event.type)"/>
```
event对象包含与创建它的特定事件有关的属性和方法。触发的事件类型不一样，可用的属性和方法也不一样，下面的是所有事件都有的：
| 属性/方法 | 类型 | 说明 |
| :--- | :--- | :--- | 
| bubbles | boolean | 事件是否冒泡 |
| cancelable | boolean | 是否可以取消事件的默认行为 |
| currentTarget | Element | 七事件处理程序当前正在处理事件的那个元素 |
| defaultPrevented | boolean | true表示调用了preventDefault()方法.DOM3新增 |
| detail | Integer | 与事件相关的信息细节 |
| eventPhase | Integer | 调用事件处理程序阶段：1捕获极端 2处于‘目标’阶段 ， 3冒泡阶段 |
| preventDefault() | Function | 取消事件默认行为，当cancelable为true才能使用 |
| stopImmediatePropagation() | Function | DOM3:取消事件进一步捕获或冒泡，同时阻止任何事件处理程序被调用 |
| stopPropagation() | Function |  取消事件进一步捕获或冒泡 ，bubbles为true才能调用 |
| target | Element | 事件目标 |
| trusted | boolean | 为true表示事件是浏览器生成的。false表示是开发人员通过JavaScript·1生成的 |
| type | String | 被触发的事件的类型 |
| view | AbstractView | 与事件关联的抽象视图。等同于发生事件的window对象 |

在事件处理内部，对象this始终等于currentTarget的值。而target则只包含实际目标。
```javascript
var btn = document.getElementById('btn');
btn.onclick = function(event) {
    console.log(event.target === this); // true
    console.log(event.currentTarget == this); // true
}
```
如果事件处理程序存在于按键的父节点中(例如document.body),那么这些值不相等
```javascript
var btn = document.getElementById('btn');
document.body.onclick = function(event) {
    console.log(event.currentTarget === document.body); // true
    console.log(this == document.body); // true

    //btn才是click事件真正的目标，由于按钮没有注册事件处理函数，结果click事件就冒泡到了document.body。在哪里进行了事件处理。
    alert(event.target === btn); // true
}
```
阻止特定事件的默认行为,当cancelable为true才能使用preventDefault()来阻止默认行为。下面如果alink的hre点击后应该跳转，但是这里却阻止了，因此跳转不会有效果。
```javascript
var link = document.getElementById('alink');
link.onclick = function(event) {
    event.preventDefault();
}
```
当bubbles为true时，stopPropagation()可以阻止事件捕获或冒泡。下面的情况如果不使用e.stopPropagation()，点击按钮会弹出两个提示框。
```javascript
var btn = document.getElementById('myBtn');
btn.onclick = function(event) {
    alert('clicked');
    e.stopPropagation();
};
document.body.onclick = function(event) {
    alert('body clicked');
};
```
事件流处于哪个阶段可以使用eventPhase属性来确认。如果是捕获阶段调用的事件处理程序，那么eventPhase等于1，如果事件处理程序处于目标对象上，eventPhase等于2，如果在冒泡阶段，eventPhase等于3.
下面的例子，当点击按钮时，首先执行的是被触发的事件处理程序是在捕获阶段添加到document.body的。然后会触发在按钮上注册的事件处理程序。最后一个触发在冒泡阶段才执行添加到document.body身上的那一个。
```javascript
var btn = document.getElementById('btn');
btn.onclick = function(event) {
    alert(event.eventPhase); // 2
}
document.body.addEventListener('click', function(event) {
    alert(event.eventPhase); // 1
}, true);
document.body.onclick = function(event) {
    alert(event.eventPahse);// 3
};
```

## IE中的事件对象
与访问DOM的event对象不一样。访问IE中的event对象有几种不同的方式。取决于制定处理程序的方法。
- DOM0级处理：event对象作为window对象的一个属性
- DOM2级处理： event作为对象传入到处理函数中.但也可以使用window.event访问
- HTML特性指定事件处理程序： 可以通过event变了访问
```javascript
// DOM0
var btn = document.getElementById('btn');
btn.onClick = function() {
    // console.log(this);
    var event = window.event;
    console.log(event.type); // click
}

// DOM2
btn.attachEvent('onclick', function(event) {
    // console.log(this);
    console.log(event.type);
    console.log(window.event.type);
});

```
HTML特性指定事件处理函数
```html
<input type="button" value="click me" onclick="alert(this);alert(event.type)"/>
```
IE的event对象同样包含属性和方法。
| 属性/方法 | 类型 | 说明 |
| :--- | :--- | :--- | 
| cancelBubble | boolean | 默认false,设置为true就可以取消事件冒泡，等同于DOM的stopPropagation() |
| returnValue | boolean | 默认值为true,设置为false可以取消事件的默认行为。等同于DOM的preventDefault() |
|srcElement | Element | 事件的目标(与DOM中的target属性相同) |
| type | String | 被触发的事件的类型 |
因为事件处理程序的作用域是根据指定它的方式来确定的，所以不能认为this会始终等于事件目标。最好还是使用event.srcElement比较保险：
```javascript
var btn = document.getElementById('btn');
btn.onclick = function() {
    alert(window.event.srcElement === this); // true
};
btn.attachEvent('onclick', function(event) {
    alert(event.srcElement === this); //false
});
```
IE取消绑定的默认行为
```javascript
var link = document.getElementById('alink');
link.oncick = function() {
    window.event.returnValue = false;
};
```

IE中阻止冒泡事件
```javascript
var btn = document.getElementById('btn');
btn.oncick = function() {
    alert('clicked');
    window.event.cancelBulle = true;
}
document.body.onclick = function() {
    alert('body clicked');
};
```

## 跨浏览器的事件对象
虽然DOM和IE的eent对象不同，但是还是可以实现相同的方法：
```javascript
var eventUtil = {
    addEvent: function(el, eventName, eventFunc) {
        if (el.addEventListener) {
            el.addEventListener(eventName, eventFunc);
        } else if(el.attachEvent) {
            el.attachEvent('on' + eventName, eventFunc);
        } else {
            el['on' + eventName] = eventFunc;
        }
    },
    removeEvent: function(el, eventName, eventFunc) {
        if (el.addEventLisremoveEventListenertener) {
            el.removeEventListener(eventName, eventFunc);
        } else if(el.detachEvent) {
            el.detachEvent('on' + eventName, eventFunc);
        } else {
            el['on' + eventName] = null;
        }
    },
    getEvent: function(event) {
        return event || window.event;
    },
    getTarget: function(event) {
        return event.target || event.srcElement;
    },
    preventDefault: function(event) {
        if (event.preventDefault) {
            event.preventDefault();
        } else {
            event.returnValue = false;
        }
    },
    stopPropagation: function(event) {
        if (event.stopPropagation) {
            event.stopPropagation();
        } else {
            event.cancelBulle = true;
        }
    }
};
```