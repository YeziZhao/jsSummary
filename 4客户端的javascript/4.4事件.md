# 事件流
如果你单击了某个按钮，单击事件不仅仅发生在按钮上。在单击按钮的同时，你也单击了按钮的容器元素，甚至也单击了整个页面。IE的事件流是事件冒泡流。Netscape Communicator的事件流是事件捕获流。
## 事件冒泡
IE的事件流是时间冒泡（event bubbling）.当事情开始时由最具体的元素(文档中嵌套层次最深的节点)接收。然后逐级向上传播到不具体的文档。
```html
<!DOCTYPE html>
<html>
    <body>
        <div>Click me</div>
    </body>
</html>
```
如果单机了<div>元素，则click事件传入顺序： div => body => html => document.每一级都会发生直到传播到document对象上。
## 事件捕获
netscape Communicator提出另一种事件流：事件捕获（event capturing)。先从不具体的节点接收到事件，最具体的节点最后接收到事件。事件捕获意义：在事件到达预定目标前捕获它。上面的例子单机div后触发的click事件：document => html => body => div。
事件捕获使用的比较少，一般使用事件冒泡。

## DOM事件流
"DOM2级事件"规定的时间流包含三个阶段：
- 捕获阶段： 为截获事件提供机会。捕获是从下图 1-3 步骤，到达div之前停止。
- 处于目标阶段：到达div
- 时间冒泡阶段: 事件发生到div上，并且事件又传播到文档。4-7步骤
![](/assets/event1.png)<br>

# 事件处理程序
事件就是用户或浏览器的某种动作，例如click, load, mouseover是事件名字.而响应某个事件就是事件处理程序。事件处理程序由`on`开头。因此click事件处理程序为onclick,load事件处理程序为onLoad。
## HTML事件处理程序
某个元素支持某种事件，使用一个与相应事件的事件处理程序同名的HTML特性来指定。
- event: 直接访问时间对象。不需要自己定义它，也不用从函数参数列表中读取。
- this: 等于时间目标元素，这里是input节点HTMLElement
```html
<input type="button" value="click me" onClick="alert(event.type + this.value);">

<!-- 拓展作用域 -->
<input type="button" value="click me" onClick="function() {
    with(this.form) {
        with(this) {

        }
    }
}">

<input type="button" value="click me" onClick="try {alert(event.type + this.value);} catch(e) {}">
```
缺点：
- 当html元素加载完毕，但是事件还未具备执行条件，点击按钮抛异常。使用异常捕获处理。
- HTML代码合js代码紧密耦合。
- 这样扩展事件处理程序的作用域链在不同浏览器中会导致不同结果。不同 JavaScript 引擎遵循的标识符解析规则略有差异，很可能会在访问非限定对象成员时出错。

## DOM0级事件处理程序
每个元素（包括window，document）都有自己的事件处理程序属性，通常属性都是小写。例如onclick.将这种属性的值设置为一个函数，就可以指定事件处理程序了。
- 在代码运行前，不会为元素指定事件处理程序。如果运行位于加载页面元素之后，可能有段时间点击没反应
- this: 事件处理程序被认为是元素方法，this指向当前元素
```javascript
var btn = document.getElementById('btn');
btn.onclick = function() {
    alert(this.id);
};
```
这种方式添加的处理程序会再事件流的冒泡阶段被处理。可以删除DOM0级指定的事件处理程序。
```javascript
btn.onclick = null;
```

## DOM2级事件处理程序
DOM2级事件处理程序定义了两个方法，用于处理指定和删除事件处理程序。有三个参数（要处理的事件名， 事件处理程序的函数， true捕获阶段调用事件处理程序false冒泡阶段调用事件处理程序[默认false]）。
- addEventListener(eventName, function, booleanValue)
- removeEventListener()(eventName, function, booleanValue)
```javascript
var btn = document.getElementById('btn');
btn.addEventListener('click', function() {
    alert(this.id);
});

btn.addEventListener('click', function() {
    console.log(this.value);
}, true);
```
上面添加了两个事件，会按照添加它们的顺序触发。通过addEventListener添加的时间，必须使用removeEventListener移除。匿名函数无法删除。
```javascript
// 没用
btn.removeEventListener('click', function() {
    alert(this.id);
});

var btn = document.getElementById('btn');
var handle = function() {
    alert(this.id);
};
btn.addEventListener('click', handle);
btn.removeEventListener('click', handle);
```
大多数情况下都是讲时间处理程序添加到事件流的冒泡阶段，最大限度兼容各种浏览器。如果不是特别需要，不建议在事件捕获阶段注册事件处理程序。

## IE事件处理程序
IE实现类似DOM中类似的两个方法，参数（事件处理程序名称，事件处理程序函数）。IE8及以前只支持事件冒泡，因此默认添加到事件冒泡阶段。
- attachEvent(eventName, function)
- detachEvent(eventName, function)
IE操作与DOM不一样的地方：
- 添加处理事件名称不一样
- 处理第一个参数，添加的与DOM事件处理程序参数不一样，IE是`onclick`.DOM是`click`.
- 事件处理程序作用域：DOM0级别程序会在其所属元素的作用域内运行。attachEvent会事件处理程序会在全局作用域中运行。this是window

