# DOM简介
DOM是针对HTML和XML文档的API(应用程序编程接口).DOM描绘了要给层次化的节点数。允许开发人员进行添加，修改，删除页面的某一部分。
```html
<html>
    <head>
        <title>
            Sample Document
        </title>
    </head>
    <body>
        <h1>Html h1 Text</h1>
        <p>This is a <i>sample</i>document</p>
    </body>
</html>
```
该html对应的DOM树如下：
![](/assets/dom2.png)
DOM1级定义了Node接口，DOM中的所有节点都是实现于该接口。在javascript中作为Node类型实现。除IE之外可以直接访问。DOM中所有节点都继承自Node类型，因此拥有Node类共享的相同基本属性和方法。文档节点的部分层次结构：
- Document类型: 代表一个HTML或则XML文档
- Element类型：代表document文档中的一个元素
- HTMLDocument类型： 针对HTML的文档
- HTMLElment类型： 代表HTML文档中的元素
- CharacterData: Text和Comment的祖先，定义这样中节点所有的共享方法。
- Comment节点：代表HTML或XML的注释(字符串)
- Text: 文档中显示文本的Text节点
- Attr节点：代表HTML和XML的属性。它几乎不适用。因为和文档节点不同，Element类型定义了将属性作为`键/值`对使用的方法。
- DocumentFragment: 在文档中并不存在。
![](/assets/dom3.png)

# 节点层次
## Node类型
Node 节点在IE中是无效的。
### Node节点属性
- nodeType属性： 代表节点类型，由12个数值常量表示
- nodeName属性： 元素的标签名称(最好先判断是否是element元素再获取)
- nodeValue属性: 对于element元素，始终存储为null
```javascript
Node.ELEMENT_NODE; // 1,代表Element节点
Node.ATTRIBUTE_NODE; // 2, 代表Attr属性节点
Node.TEXT_NODE; // 3, 代表Text文本节点   
Node.CDATA_SECTION_NODE; // 4
Node.ENTITY_REFERENCE_NODE; // 5
Node.ENTITY_NODE; // 6
Node.PROCESSING_INSTRUCTION_NODE; // 7
Node.COMMENT_NODE; // 8 
Node.DOCUMENT_NODE; // 9
Node.DOCUMENT_TYPE_NODE; // 10
Node.DOCUMENT_FRAGMENT_NODE; // 11
Node.NOTATION_NODE; // 12
```
![](/assets/dom4.png)
判断节点的nodeTpe
```javascript
if (someNode.nodeType === Node.ELEMENT_NODE) {
    console.log('node is an element');
}

// IE没有Node函数，可以通过下面方式
if (someNode.nodeType === 1) {
    console.log('node is an element');
    console.log(someNode.nodeName); 
    console.log(someNode.nodeValue);
}
```
### 获取节点
- childNodes： 保存一个NodeList对象。NodeList是类数组,保存一组有序的节点，可以通过位置访问节点。NodeList时基于DOM结构动态执行查询的结果，DOM结构的变化能够自动反应在NodeList对象中。注意：动态，会变化。
- parentNode： 只想文档树中父节点。
- previousSibling: 同层级的前面的前一个兄弟节点, 没有为null
- nextSibling: 同层级的后面相邻的一个兄弟节点，没有为null
- firstChild: 指向childNodes的第一个子节点
- lastChild: 只想childNodes的最后一个子节点
- ownerDocument: 只想整个文档的文档根结点，不必通过层层回溯到达顶端，可以直接访问文档节点。
- hasChildNode(): 有child,返回true,无返回false
```javascript
var childs = someNode.childNodes();
var firstChild = childs[0]; // 使用类数组索引方式访问
var secondChild = childs.item(1); // 使用item方法访问
var count = childs.length;
```
![](/assets/dom5.png);
NodeList是类数组，可以使用call or apply执行Array的所有方法。
```javascript
function nodeToArray(nodes) {
    try {
        return Array.prototype.slice.apply(node, 0);
    } catch (e) {
        var arrs = Array();
        for (var i = 0; i < nodes.length; i++) {
            arrs.push(nodes[i]);
        }
        return arrs;
    }
}

// es6
new Array(...document.getElementById('home').childNodes);
```
![](/assets/dom6.png)

### 节点操作
- appendChild()： 在childNodes末尾添加子节点，父节点的引用指针、childNodes最后一个子节点的关系指针都会更新。返回新增的子节点。如果添加的是文档中已有的节点，则相当于是移动已有节点的位置到最后。相当于移动，不是复制。
- insertBefore(intertNode, referNode): 讲intertNode插入到referNode的前面。如果第二个参数为null,则相当于appendChild.插入后，将intertNode作为referNode的previousSibling.
```javascript
// 创建新节点
var newNode = document.createTextNode('hello, wold');
var parent = document.getElementById('home');
var returnNode = parent.appendChild(newNode);
console.log(newNode === returnNode); // true
console.log(parent.lastChild === newNode); // true

// 移动已存在的节点
var needMove = parent.firstChild;
var returnNeedMove = parent.appendChild(needMove);
console.log(needMove == returnNeedMove); // true: needMove地址引用，值没有改变
console.log(returnNeedMove == parent.firstChild); // false
console.log(returnNeedMove == parent.lastChild); // true

// intertBefore
parent.insertBefore("xxx")
```