# 1 DOM简介
DOM是针对HTML和XML文档的API(应用程序编程接口).DOM描绘了要给层次化的节点数。允许开发人员进行添加，修改，删除页面的某一部分。
```html
<html>
    <head>
        <title>
            Sample Document
        </title>
    </head>
    <body>
        <h1>Html h1 Text</h1>
        <p>This is a <i>sample</i>document</p>
    </body>
</html>
```
该html对应的DOM树如下：
![](/assets/dom2.png)
DOM1级定义了Node接口，DOM中的所有节点都是实现于该接口。在javascript中作为Node类型实现。除IE之外可以直接访问。DOM中所有节点都继承自Node类型，因此拥有Node类共享的相同基本属性和方法。文档节点的部分层次结构：
- Document类型: 代表一个HTML或则XML文档
- Element类型：代表document文档中的一个元素
- HTMLDocument类型： 针对HTML的文档
- HTMLElment类型： 代表HTML文档中的元素
- CharacterData: Text和Comment的祖先，定义这样中节点所有的共享方法。
- Comment节点：代表HTML或XML的注释(字符串)
- Text: 文档中显示文本的Text节点
- Attr节点：代表HTML和XML的属性。它几乎不适用。因为和文档节点不同，Element类型定义了将属性作为`键/值`对使用的方法。
- DocumentFragment: 在文档中并不存在。
![](/assets/dom3.png)

## 1.1 Node类型
Node 节点在IE中是无效的。
### 1.1.1Node节点属性
- nodeType属性： 代表节点类型，由12个数值常量表示
- nodeName属性： 元素的标签名称(最好先判断是否是element元素再获取)
- nodeValue属性: 对于element元素，始终存储为null
```javascript
Node.ELEMENT_NODE; // 1,代表Element节点
Node.ATTRIBUTE_NODE; // 2, 代表Attr属性节点
Node.TEXT_NODE; // 3, 代表Text文本节点   
Node.CDATA_SECTION_NODE; // 4
Node.ENTITY_REFERENCE_NODE; // 5
Node.ENTITY_NODE; // 6
Node.PROCESSING_INSTRUCTION_NODE; // 7
Node.COMMENT_NODE; // 8 
Node.DOCUMENT_NODE; // 9，表示document

Node.DOCUMENT_TYPE_NODE; // 10
Node.DOCUMENT_FRAGMENT_NODE; // 11
Node.NOTATION_NODE; // 12
```
![](/assets/dom4.png)
判断节点的nodeTpe
```javascript
if (someNode.nodeType === Node.ELEMENT_NODE) {
    console.log('node is an element');
}

// IE没有Node函数，可以通过下面方式
if (someNode.nodeType === 1) {
    console.log('node is an element');
    console.log(someNode.nodeName); 
    console.log(someNode.nodeValue);
}
```
### 1.1.2 节点查询
- childNodes： 保存一个NodeList对象。NodeList是类数组,保存一组有序的节点，可以通过位置访问节点。NodeList时基于DOM结构动态执行查询的结果，DOM结构的变化能够自动反应在NodeList对象中。注意：动态，会变化。
- parentNode：指向文档树中父节点。
- previousSibling: 同层级的前面的前一个兄弟节点, 没有为null
- nextSibling: 同层级的后面相邻的一个兄弟节点，没有为null
- firstChild: 指向childNodes的第一个子节点
- lastChild: 指向childNodes的最后一个子节点
- ownerDocument： 整个文档的文档根结点，不必通过层层回溯到达顶端，可以直接访问文档节点。
- hasChildNode(): 有child,返回true,无返回false
```javascript
var childs = someNode.childNodes();
var firstChild = childs[0]; // 使用类数组索引方式访问
var secondChild = childs.item(1); // 使用item方法访问
var count = childs.length;
```
![](/assets/dom5.png);
NodeList是类数组，可以使用call or apply执行Array的所有方法。
```javascript
function nodeToArray(nodes) {
    try {
        return Array.prototype.slice.apply(node, 0);
    } catch (e) {
        var arrs = Array();
        for (var i = 0; i < nodes.length; i++) {
            arrs.push(nodes[i]);
        }
        return arrs;
    }
}

// es6
new Array(...document.getElementById('home').childNodes);
```
![](/assets/dom6.png)

### 1.1.3 节点增加，伤处，修改，复制
- appendChild()： 在childNodes末尾添加子节点，父节点的引用指针、childNodes最后一个子节点的关系指针都会更新。返回新增的子节点。如果添加的是文档中已有的节点，则相当于是移动已有节点的位置到最后。相当于移动，不是复制。
- insertBefore(insertNode, referNode): 将insertNode插入到referNode的前面。如果第二个参数为null,则相当于appendChild.插入后，将insertNode作为referNode的previousSibling.
- replaceChild(insertNode, deleteNode): 将deleteNode移除文档作为操作结果返回，将insertNode替换到删除的位置,并复制被删除节点的所有关系指针。
- replaceChild(node): 移除节点，移除的节点仍然为文档所有，但是在文档中已经没有自己的位置。
- cloneNode(bool): 创建一个节点完全相同的副本。bool:true表示深度克隆(复制节点即整个子节点)。false浅度克隆，只复制节点本身。复制后返回节点副本，没有指定父节点。
- normalize(): 由于解析器原因，DOM中可能出现不包含文本，或者包含两个文本节点的请看。如果找到空文本节点，会删除，如果两个连续的文本节点，会合并。
```javascript
// 创建新节点
var newNode = document.createTextNode('hello, wold');
var parent = document.getElementById('home');
var returnNode = parent.appendChild(newNode);
console.log(newNode === returnNode); // true
console.log(parent.lastChild === newNode); // true

// 移动已存在的节点
var needMove = parent.firstChild;
var returnNeedMove = parent.appendChild(needMove);
console.log(needMove == returnNeedMove); // true: needMove地址引用，值没有改变
console.log(returnNeedMove == parent.firstChild); // false
console.log(returnNeedMove == parent.lastChild); // true

// intertBefore
var insertNode = parent.insertBefore(newNode, null); 
console.log(newNode === parent.lastChild);
var insertNode2 = parent.insertBefore(newNode, parent.childNodes[2]);
console.log(insertNode == parent.childNodes[2]);

// replaceChild
var replace = document.createTextNode('replace node');
var replaceNode = parent.replaceChild(replace, parent.firstChild);

// removeChild
var removeChild = parent.removeChild(parent.firstChild);

// cloneNode
var cloneNode = parent.firstChild.cloneNode(true);
parent.insertBefore(parent.firstChild);
```

## 1.2 Document类型
Javascrip使用Document类型表示文档，web浏览器中，document对象时HTMLDocument的实例。document对象时window对象的一个属性。因此可以作为全局对象访问。
- nodeType： 9
- nodeName: '#document'
- nodeValue: null
- parentNode: null
- ownerDocument: 整个文档根节点，null
- 子节点可能时DocumentType(最多一个)，Element(最多一个)， ProcessingInstruction或comment
![](/assets/dom7.png)

### 1.2.1 document属性
- childNodes()
- documentElement属性： 始终指向html元素。
- body属性： 失踪只想页面元素body
- docType属性： DocumentType类型。`<!DOCTYPE>`标签，看成与要给文档其他部分不同的实体。
- title: 浏览器的标题
- URL: 页面完整的URL，不可修改
- domain: 只包含域名，可修改，但只能修改为当前域所包含的域。
- referrer： 在a页面，点击某个操作到了当前页面，保存a页面的链接。没有为空字符串。
```html
<!DOCTYPE html>
<html>
    <head></head>
    <body></body>
</html>
```
```javascript
// documentElment
var html = document.documentElement;
console.log(html === document.childNodes[1]);
console.log(html === document.lastChild);

// body属性
var body = document.body;
console.log(body === html.lastChild);

// docType属性
console.log(document.docType);

// title 属性
document.title = "yezi update";

// URL属性
console.log(document.URL);

// domain属性
console.log(document.domain);

// referrer属性
console.log(document.referrer);
```
### 1.2.2 document查找页面元素方法
NodeList => Node实例的集合， HTMLCollection => HTMLElement实例的集合
- getElementById(idName): 根据id查找元素，返回HTMLElement子对象。Document上的方法。
- getElementsByTagName(tagName): 根据标签名称获取元素，返回HTMLCollection集合。Document上的方法。 
- getElementsByName(name): 返回HTMLCollection集合, HTMLDocument的方法。

HTMLCollection:
- item(): 数字索引访问 
- namedItem(name): 根据名称访问。多个符合结果只会返回第一个。
![](/assets/dom8.png)
```html
<img src="www.baidu.com" name="imageName"/>
```
```javascript
var images = document.getElementsByTagName('img'); // HTMLCollection集合
var namedItemMethod = spans.namedItem('imageName'); // 根据名字获取
console.log(images['imageName']); // 通过名称访问。可传入数字或字符串索引值。数值索引后台会使用item(),字符串索引会使用namedItem()
```
### 1.2.3 document的特殊集合
返回的都是HTMLCollemction
- anchors:  返回文档中所有带name特性的<a>元素
- applets: 返回文档中所有<applets>.现已不使用
- forms: 返回文档中包含的所有<form>元素，相当于document.getElementsByTagName('form');
- images: 返回文档中所有<img>元素
- links: 返回文档中所有带href的<a>元素
### 1.2.4 document文档写入
- write(str): 将字符串写入到页面，原样写入。
- writeln(str):  将字符串写入页面，写完会换行
- open()： 打开网页输入流
- close()： 关闭网页输入流
```html
<html>
    <body>
		<p>the p content is origin</p>
		<script type='text/javascript'>
			document.writeln('<strong>document,writelin</strong>');
			document.write('write can\'t wrap');
			document.write('write can\'t wrap');
		</script>
	</body>
</html>
```
### 1.2.5 页面元素创建
- createElement(标签名): 创建新元素，传入参数标签名
```javascript
// createElement创建，并添加属性，节点。还没有将其放入文档流中，对文档的显示无影响。
var el = document.createElement('div');
el.lang = 'cn';
el.appendChild(newNode);
```

## 1.3 Element类型
除了Document外，Element是web编程中最常用的类型了。Element类型用于表现XML,HTML元素，提供对元素标签，子节点以及特性的访问。
- nodeType: 1
- nodeName: 元素标签名称
- nodeValue: null
- parentNode：可能是Document或Element
- 子节点： 可能是Element, text, Comment,ProcessingInstruction,CDATASection,EntityReference
元素的标签名可以使用nodeName，也可以使用tagName.
```javascript
// <div i9d="myDiv"></div>
var div = document.getElementById('myDiv');
console.log(div.tagName === div.nodeName);  // html中返回大写，xml中返回小写
```
web中，所有的html元素都是使用HTMLElement进行表示的，HTMLElement继承于Element.但是又进行了拓展，如下属性：
- id: 元素在文档唯一标识符
- title： 有关元素的附加说明信息，一般通过工具提示条显示出来
- lang： 元素内容的语言代码，很少使用
- dir： 语言方向。 ltr: left to right, rtl: right to left.很少用
- className： 与元素的class特性对应，元素css类的名称
```html
<div id="myId" title="body text" lang="en" class="bd" dir="rtl">
```
![](/assets/dom9.png)
元素获取
```javascript
var els = document.getElementsByTagName('div');
var el = document.getElementById('myId');
var els = document.getElementsByName('namestr');

// 对属性设置新值
el.lang = "cn";
el.dir = 'ltr';
el.title = 'my title change';
```

### 1.3.1 Element特性获取
- getAttribute(attr): 根据属性返回值。针对style属性，getAttribute获取返回css字符串，直接通过el.style属性获取返回对象针对onClick这样的事件，getAttribute获取返回相应代码字符串，通过属性el.onClick访问返回函数。一般都是使用属性调用方式，自定义的属性才使用这个方法。
- setAttribute(attr, value)： 给属性attr设置value值
- removeAttribute(attr): 移除attr属性，不仅删除值，还会从元素中移除属性。
- attributes: 返回一个类似NodeList的NamedNodeMap
    - getNamedItem(name): 返回nodeName=name的节点
    - removeNamedItem(name): 从列表中移除nodeName=name的节点
    - setNamedItem(node): 想列表中添加节点，以node的nodeName为节点索引
    - item(position): 返回位于数字=position位置处的节点
```javascript
// <div id="myId" title="body text" lang="en" class="bd" dir="rtl">
// 以上面的为例
var namedNodeMap = document.getElementById('myId').attributes;
console.log(namedNodeMap);
console.log(namedNodeMap.getNamedItem('title')); // title="body text"
var deleteNode = namedNodeMap.removeNamedItem('title'); // title="body text"
console.log(namedNodeMap);
var addAttr = document.createAttribute('title', 'add node"');
addAttr.value = 'add value';
namedNodeMap.setNamedItem(addAttr);
namedNodeMap.item(4);
console.log(namedNodeMap);
```
![](/assets/dom10.png)
元素的 `childNodes` 属性中包含了它的所有子节点，这些子节点有可能是元素、文本节点、注释或处理指令。不同浏览器在看待这些节点方面存在显著的不同，以下面的代码为例。
```html
<ul id="myList">
    <li>Item 1</li>
    <li>Item 2</li>
    <li>Item 3</li>
</ul>
```
如果是 IE8 来解析这些代码，那么 `<ul>` 元素会有3个子节点，分别是3个 `<li>` 元素。但如果是在其他浏览器中，`<ul>` 元素都会有7个元素，包括3个 `<li>` 元素和4个文本节点（表示 `<li>` 元素之间的空白符）。如果像下面这样将元素间的空白符删除，那么所有浏览器都会返回相同数目的子节点。用下面的方式处理：
```javascript
for (var i=0, len=element.childNodes.length; i < len; i++){
    if (element.childNodes[i].nodeType == 1){
        //执行某些操作
    }
}
```
还可以通过元素获取子元素，再获取子元素的后代节点
```javascript
var ul = document.getElementById("myList");
var items = ul.getElementsByTagName("li");
```