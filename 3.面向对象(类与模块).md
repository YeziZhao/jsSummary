
##创建对象
- 工厂模式
``` javascript
function createFactory(name, age, job) {
    var o = new Object();
    o.name = name;
    o.age = age;
    o.job = job;
    o.toString = function () {
        return "name: " + name + ", age: " + age + ", job: " + job;
    }
    return o;
}
var people1 = createFactory('p1', 20, 'doctor');
```
- 构造函数（
    1. 没有显式创建对象，
    1. 将属性赋给this,
    1. 没有return
    1. 函数名用大写开头
    1. 当做函数使用，与普通函数无区别
```javascript

// 只有构造函数
function People(name, age, job) {
    this.name = name;
    this.age = age;
    this.job = job;
    this.toString = function () {
        return "name: " + name + ", age: " + age + ", job: " + job;
    };
}

// 只有原型
function People2() {}
People2.prototype.name = "xx";
People2.prototype.age = 20;
People2.prototype.job = 'doctor';
People2.prototype.toString =  function () {
    return "name: " + name + ", age: " + age + ", job: " + job;
};

// 组合使用构造函数与原型
function People3(name, age, job) {
    this.name = name;
    this.age = age;
    this.job = job;
}
People3.prototype.toString = function () {
    return "name: " + name + ", age: " + age + ", job: " + job;
};

People3.prototype = {
    constructor: People3,
    toString: function() {
        console.log("重新写了prototype，prototype的指向对象被修改，在这修改后创建的对象的prototype将于之前创建的对象的prototype不一致");
    }
};

// 直接使用构造函数作为方法
People('global', 20, 'global');
window.toString(); //"name: global, age: 20, job: global" 
```
使用new关键字创建对象的过程
1. 创建一个新对象（实例）
1. 将构造函数的作用域赋给新对象（也就是重设了this的指向，this就指向了这个新对象）
1. 执行构造函数中的代码（为这个新对象添加属性）
1. 返回新对象

- 寄生构造函数模式(不是很懂,我理解的就是已经存在的类，然后向在该类上拓展方法，又不影响原类。那这个和继承有点类似么？)
当你需要创建一个自定义类型的时候,当前面的模式都不适用的情况下,可以使用寄生构造函数模式。这种模式的基本思想是创建一个函数,该函数的作用仅仅是封装创建对象的代码。分析其与工厂模式的区别:
1. 寄生模式创建对象时使用了New关键字
1. 寄生模式的外部包装函数是一个构造函数
除了上面这2个区别寄生模式和工厂模式几乎一样,构造函数在不返回值的情况下，默认返回对象的新实例。而通过在构造函数的末尾添加一个return 语句,可以重写调用构造函数是返回的值

```javascript
function Person(name) {
    var o = new Objcet();
    o.name = name;
    o.sayName = function() {
        return this.name;
    }
}
var person = new Person("张三");
person.sayName();

function createPersion(name) {
    var o = new Objcet();
    o.name = name;
    o.sayName = function() {
        return this.name;
    }
}
var person = createPeron("张三");
    person.sayName();
```
作用:寄生模式可以在特殊的情况下为对象来创建构造函数,原因在于我们可以通过构造函数重写对象的值，并通过return返回  重写调用构造函数(创建的对象的实例)之后的对象实例的新的值。
假设我们想创建一个具有额外方法的特殊数组。由于不能直接修改Array构造函数,所以我们可以使用寄生模式。代码如下:
```javascript
function SpecialArray() {
    var obj = new Array();
    obj.push.apply(obj, arguments);
    obj.newMethod = function () {
        return this.join(',');
    }
    return obj;
}
var colors=new SpecialArray("red","blue","black");
console.log(colors.newMethod());  //输出:red|blue|black
```
- 稳妥构造函数模式
道格拉斯 * 克罗克福德 发明了JavaScript中的稳妥对象这个概念.所谓稳妥对象,指的是没有公共属性，而且其方法也不引用this的对象。稳妥对象最适合用在一些安全的环境中(这些环境会禁止使用new和this)，或者防止数据被其他的应用改动。稳妥构造函数与寄生构造函数模式类似,但是也有两点区别:
- 稳妥模式不使用new操作符调用构造函数
- 新创建对象的实例方法不引用this
```javascript
function Person(name,age) {
    //创建要返回的对象
    var o = new Object();
    //可以在这里定义私有变量和函数
    //添加方法
    o.sayName = function(){
        alert(name);
    }
    //返回对象
    return o;
}
var person = Person("张三",22);
    person.sayName();  //使用稳妥构造函数模式只能通过其构造函数内部的方法来获取里面的属性值
```
上面的代码定义了一个person变量，里面保存的是一个稳妥对象,而除了调用他的sayName()方法外,没有别的方法可以访问其数据成员。即使有其他的代码会给这个对象添加方法和数据成员，但也不可能有别的方法访问到传入到构造函数中的原始数据。稳妥构造函数模式提供的这种安全性。是的它非常适合在某些安全执行环境中。

## 原型
类使用new关键字通过构造函数进行创建。新创建的对象都有prototype属性指向构造函数.prototype上定义的方法在所有创建的实例中时共享的。图解：
- People.prototype 指向原型对象
- 原型对象的constructor指向People构造函数：People.prototype.constructor == People
- People每个实例的__proto__指向原型对象。(注意存在于实例与原型对象，不是实例与构造函数之前)
![](/assets/prototype.png)

```javascript
function People(name, age) {
    this.name = name;
    this.age = age;

    // 不建议在构造函数内部添加方法，因此这样会在每次new的过程中，每个方法都要在每个实例上重新创建一遍，这将非常损耗性能。
    this.toString2 = function() {
        console.log('this: innter function' + this.name);
    }
}

var people = new People('yezi', 20);
console.log(people.constructor == People);  // true
console.log(people instanceof People); // true

// 要修改原型第一种：需要设置constructor
People.prototype = {
    toString: function () {
        return "name: " + this.name + ", age:" + this.age;
    }
};
Object.defineProperty(People.prototype, 'constructor', {
    value: People,
    enumerable: false,
    writable: true,
    configurable: true
});
// 因为此时的prototype已经重写，而定义people时，时使用的prototype的地址已经和现在的不一样了
var people2 = new People("prototype modify and have the new toString()", 20); 
console.log(people2.toString()); // name: prototype modify and have the new toString(), age:20
console.log(people.toString()); // [object Object]

// 第二种：直接添加方法
People.prototype.toString = function() {
    return "name: " + this.name + ", age:" + this.age;
}
```
获取对象的原型与判断
- Object.getPropertyOf()
- ClassName.isPropertyOf(instanceObject)
- instanceObject.propertyIsEnumerable(propertyName)
- instanceObject.hasOwnProperty(propertyName)
- in： 原型链也能检测
- for in: 原型链都会遍历,如果enumerable设置为false,则不能遍历
- Object.keys(instanceObject):用于获取对象自身所有的可枚举的属性值，但不包括原型中的属性，然后返回一个由属性名组成的数组。
- Object.getOwnPropertyNames()： 返回对象的所有自身属性的属性名（包括不可枚举的属性）组成的数组，但不会获取原型链上的属性。
```javascript
function People(name, age) {
    this.name = name;
    this.age = age;
}
People.prototype.toString = function() {
    return "name: " + this.name + ", age:" + this.age;
};
var people = new People("yezi", 20);
console.log(Object.getPrototypeOf(people));
console.log(People.prototype.isPrototypeOf(people)); // true
console.log(people.hasOwnProperty('name')); // true
console.log(people.propertyIsEnumerable('age')); // true
console.log(people.constructor); // constructor属性是在原型链上的，不是对象自身的属性

console.log('toString' in people); // true
for(var item in people) {
    console.log(item); // name age toString
}

Object.defineProperty(people, 'job', {value: "doctor"， enumerable: true})
console.log(Object.keys(people)); // [name, age, doctor],

```


## 面向对象的特点
1. 类
1. 构造函数
1. 属性
1. 方法
1. 封装
1. 继承
1. 多态
1. 抽象(抽象出来的类或方法)

-  原型链继承
问题：
1. 原型的构造函数指向父类，原型实际变成另一个类型的实例，父类中的属性顺理成章变成现在的原型属性。父类中的属性会被不同实例共享。
1. 创建子类型的实例时，不能向父类型中传递参数。没办法在不影响所有对象实例的情况下给父类传递参数。
```javascript
function Super() {
    this.name = "super";
    this.arrColor = [];
}
Super.prototype.getSuperName = function() {
    return this.name;
}
function Child() {
    this.name = "child";
    this.age = 10;
}
Child.prototype = new Super();

// 添加方法或重写要放在替换原型之后
Child.prototype.getChildName = function() {
    return this.name + this.age;
};
Child.prototype.getSuperName = function() {
    return this.age;
}

var c = new Child();
console.log(c.__proto__);
console.log(Child.prototype);
console.log(c.getChildName());

console.log(c instanceof Object); // true
console.log(c instanceof Super); // true
console.log(c instanceof Child); // true

// 只要原型链中出现过的都是实力的原型
console.log(Object.prototype.isPrototypeOf(c)); // true
console.log(Super.prototype.isPrototypeOf(c)); // true
console.log(Child.prototype.isPrototypeOf(c)); // true

// 父类中的属性会被不同实例共享。
Super.prototype.setColor = function (color) {
    this.arrColor.push(color);
};
c.setColor('red');
var b = new Child();
console.log(b.arrColor); // ['red']
```
此时Child的实例的constructor是指向的Super.因此Child的prototype重写的原因。变量搜索如下：
- 搜索Child的实例对象
- 搜索Child的prototype
- 搜索Super的prototype
![](/assets/extend.png)
下面时加上object继承的图解：
![](/assets/allExtend.png)