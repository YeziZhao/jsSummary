# 1.ECMAScript 简介

- 通常作为 JavaScript 的标准化规范
- JavaScript 是 ECMAScript 的拓展语言，ECMAScript 只是提供了最基本的语法，是一种规格，而 JavaScript 则是具体的实现。<br>
  ![alt text](image.png)<br>

## 1.1 ECMAScript 标准是谁定制？

TC39 - 即 ECMA 组织的 39 号技术委员会，是一个推动 JavaScript 发展的委员会，由总舵互联网公司和各大主流浏览器厂商的代表共同组建，是一个开放性的指导委员会。当前 ECMSAScript 标准都是由 TC39 委员会制定的。

## 1.2 ES6 与 ECMAScript 2015 的关系

2011 年，ECMAScript 5.1 版发布后就开始制定 6.0 版。因此 ES6 这个词的原意指 JavaScript 语言的下一个版本。正常的版本迭代应该是 6.0， 6.1， 6.2 等等, 但是因为新版本的语法功能太多，且制定过程中还有其他人和组织不断地提交新功能，因此无法再一个版本中引入所有的功能。最后制定者将标准流程升级：<br>
![alt text](image-1.png)<BR>

最后[制定流程](https://tc39.es/process-document/)：<br>
| 阶段 | 描述 |
| :--- | :--- |
| Stage 0 |Strawman（展示阶段）|
| Stage 1 |Proposal（征求意见阶段）|
| Stage 2 |Draft（草案阶段）|
| Stage 3 |Candidate（候选人阶段）|
| Stage 4 |Finished（定案阶段）|

ES6 的第一个版本于 2015 年 6 发布，正式命名为 ES2015(ECMAScript 2015),之后都以年份命名 ES2015,ES2016,ES2017...ES2024,在这之后 ES6 成为一个历史名词，表示 Javascript 的下一代标准,涵盖了 ES2015,ES2017...

## 1.3 Babel

Babel 是 ES6 转码器，将 ES6 转为 ES5,从而在老版本浏览器运行。
| name | 作用 |
| :--- | :--- |
| @babel/core |是 Babel 的核心包，将 JavaScript 代码解析成抽象语法树（‌AST），使得其他插件能够分析和转换这些代码 ‌，例如处理箭头函数等新的语法特性|
| .bablerc | babel 配置文件，设置转码规则和插件{ "presets": ["@babel/preset-env","@babel/preset-react"],"plugins": [] }|
| @babel/preset-env |是预设是一系列插件的集合，包含了常用 es2015,es2016, es2017 等最新的语法转化插件，允许我们使用最新的 js 语法，比如 let，const，箭头函数等等，但不包含低于 Stage 3 的 JavaScript 语法提案|
| @babel/preset-react | Babel 的一个插件预设，它用于将 React JSX 语法转换为 React.createElement 调用。它提供了处理 JSX 语法和 React 组件的能力|
| @babel/cli |babel 自带的命令行集成工具,可在 cmd 运行 babel 解析过程。并可以设置包括输出路径等等信息（npx babel example.js --out-file compiled.js）|
|@babel/node|是一个与 Node.js CLI 完全相同的 CLI， 除此之外，还具有在运行之前使用 Babel 预设和插件进行编译的额外优势。提供一个支持 ES6 的 REPL 环境。它支持 Node 的 REPL 环境的所有功能，而且可以直接运行 ES6 代码|
|@babel/register| 改写 require 命令，为它加上一个钩子。此后，每当使用 require 加载.js、.jsx、.es 和.es6 后缀名的文件，就会先用 Babel 进行转码，但它只会对 require 命令加载的文件转码，而不会对当前文件转码。另外，由于它是实时转码，所以只适合在开发环境使用|
|polyfill|Babel 默认只转换新的 JavaScript 句法（syntax），而不转换新的 API。如 Iterator,Generator,Set, Map 等全局对象，都不会转码，如果要执行这些方法，则需要为当前环境暗转垫片（core-js, regenerator-runtime）|

# 2. ES6新语法
| name | 编写 | 注意点|
| :--- | :--- |--- |
| let|代码块内有效 |1. let为局部变量，var为全局变量，当var执行时，每一次循环，i的值都将变更：<br> `let a = []; for (let i = 0; i < 10; i++) {a[i] = () => {console.log(i)}}; a[1]();` => 1 <br/> `let a = []; for (var i = 0; i < 10; i++) {a[i] = () => {console.log(i)}}; a[1]();` => 10<br><br> 2. 无变量提升：<br/>`typeof x; let x;` => 将报错 <br/> `(x = y, y = 3) => x + y` => 将报错 <br><br> 3. 同一作用于不能重复 |
|const|只读常量，一旦申明，无法变更|1. 作用域与let相同，<br/>2. 不存在变量提升<br>3. 需要先定义后使用<br>4. const实际是只想的内存地址的数据不能变更：`const a = {x: 1}; a.x = 10; `, 它的属性是可以修改的|
| 析构|按照一定模式，从数组和对象中提取值，对变量进行赋值<br/>右边需是具备Iterator接口的数据|1. 数组析构：<br>`let [x, y, z] = [{a: 1}, 10, []]`<br>`let [a, [b], [[c]], x] = ['avalue', ['bvalue'], [['cvalue']]] ` => x等于undefined <br/>`let [x, y, z] = new Set(['a', 'b', 'c']);`<br/>let [x = 1, y = x] = [1, 2]; <br/><br>2. 对象析构：<br>`let { first: f,second, last = 10} ={ first: 'hello'}; ` => f 等于hello, second默认值undefined, last 等于默认值10, first是模式，变量名为f <br>和数组一样，可深层嵌套，`let { p, p: [x, { y }] } = {p: ['Hello',{ y: 'World' }]}` => 不仅p可以被赋值，x,y还能析构value <br/><br>3. 析构特别用法：<br> `交换变量：let x = 10; let y = 20; [x, y] = [y, x]` <br>`遍历Map析构key: const map = new Map();map.set('first', 'hello');for (let [key, value] of map) {}` <br/>`var {x:y = 3} = {x: 5};` => x模式取值，value为5，赋值给y, y=> 5 <br/>`const arr = [1,2,3];const {0:first, [arr.length-1]: last} = arr;` => first: 1, last: 3|
|字符串|拓展新的支持|1. 对 Unicode 的支持：<br>`限于码点在\u0000~\uFFFF之间的字符。超出这个范围的字符，必须用两个双字节的形式表示："\uD842\uDFB7" =>  "𠮷" `<br>`在\u后面跟上超过0xFFFF的数值（比如\u20BB7），JavaScript 会理解成\u20BB+7,ES6使用大括号，能正确解读：'hell\u{6F}' => hello, "\u{41}\u{42}\u{43}" => abc , '\u{1F680}' === '\uD83D\uDE80' => true`<br><br>2. 添加遍历器接口,使得字符串可通过`for...of`遍历（可遍历Unicode ）：<br>`for(let x of 'abc') {console.log(x); // 输入a b c}`<br><br>3. 使用\`\`增强模板字符串来标识，模板字符串的大括号内部，就是执行 JavaScript 代码：<br>\`hello ${name}，1 + 1 = ${1+1}\`<br><br>4. 可以换行表示多行字符串 <br>5.标签模板：<br >functionName\`hello\` => 等价于functionName(['hello']) <br> 模板字符里面有变量，会将模板字符串先处理成多个参数，再调用函数,变量作为后面的参数: let a = 10 ; let b = 5; functionName\`hello ${a + b}, world, ${a}\` => 等价于functionName(['hello', 'world'], 15, 5)|
| String Method | 新增方法 | 1. String.fromCodePoint(): ES5的`String.fromCharCode()`只能识别小于`0xFFFF`的`Unicode 码点`, String.fromCodePoint()范围更大，String.fromCodePoint方法有多个参数，则它们会被合并成一个字符串返回。<br>`String.fromCodePoint(0x78, 0x1f680, 0x79) === 'x\uD83D\uDE80y'`<br><br> 2.String.raw():返回一个斜杠都被转义的字符串<br>String.raw\`Hi\n${2+3}!\` => 'Hi\\n5' <br><br> 3.codePointAt(): 如果是4个字节的字符，ES5的`charCodeAt`只能分别返回前两个字节和后两个字节的值，而`codePointAt`可以正确处理4 个字节储存的字符。<br> 测试字符是由4个字节组成：`const is32Bit = (c)=> c.codePointAt(0) > 0xFFFF;` <br>正确读取字节内容，使用`for of`或者拓展运算法:<br>- `let s = '𠮷a'; for(let c of s) {console.log(c.codePointAt(0).toString(16));}`<br> - `let c = [...s]; c.forEach(d => console.log(d.codePointAt(0).toString(16)))`<br><br> 4. normalize(): 有些语言由语调符号和重音符号，Unicode提供2种方式，直接提供重音符号`例如Ǒ（\u01D1）`，还有一种是合成符号，由`O（\u004F)` 和`ˇ（\u030C）`组成`Ǒ`，语义等价，但js无法识别，可通过`normalize处理`：<br>`'\u01D1'.normalize() === '\u004F\u030C'.normalize()` <br>不能识别三个或三个以上字符的合成。这种情况下，还是只能使用正则表达式 <br><br> 5.include(),startWith(), endWith(), repeat():<br>include(): 是否包含参数字符串<br>startWith():是否以参数字符串作为头部<br>endWith(): 是否以参数作为尾部<br>repeat(n):将字符串重复n次返回, 参数如果是小数，会取整数位参数，为负或Infinity数则报错，0 到-1 之间的小数，则等同于 0，NAN等同于0，是字符串则先转为数字， `'x'.repeat(5) => xxxxx`<br><br> 6. matchAll():返回一个正则表达式在当前字符串的所有匹配<br> replaceAll():与replace()类型，但是匹配多次：`'aabbcc'.replaceAll('b', '_') 等价 'aabbcc'.replace(/b/g, '_')`<br> 替换文本可是特殊字符：<br>`'abc'.replaceAll('b', '$&')` => `$&`匹配字符本身，即 字符`b`,返回`abc` <br> 'abbbc'.replaceAll('b', '\$\`') => \$\`:匹配结果之前的字符串， 第一个b前面是a, 第二个b前面是ab, 所以第一个b替换为a,第二个b替换为ab,第三个b替换为abb => 'aaababbc'<br>'abbbc'.replaceAll('b', \`\$'\`) => \$': 匹配结果后面的文本，'abbcbccc'  <br> 'abbc'.replaceAll(/(ab)(bc)/g, '$2$1') => $2是bc, $1是ab, 交换两个位置， 结果是bcab <br>'abc'.replaceAll('b', '\$\$') => $$就是$符号，输出 $ <br><br> 7.at():一个整数作为参数，返回参数指定位置的字符，支持负索引（即倒数的位置）<br> 'hello'.at(-1) => 输出o |
|RegExp 正则|es5: RegExp('xyz', 'i') or RegExp(/xyz/i) <br> es6: RegExp(/xyz/ig, 'i') => i会替换ig修饰符 |1.es5字符串的`match()/replace()/search()/split()`, ES6都实现到了`RegExp`身上 <br><br>2.加上u修饰符号,支持资格字节的UTF-16编码:<br> - `/^\uD83D/u.test('\uD83D\uDC2A')` => false <br> - (.): 表示处换行符外的任意单个字符，使用`u`修饰符，正确校验长度：`var s = '𠮷';/^.$/u.test(s)`  => true（es5会认为这个长度为2，2个字符）<br>-使用大括号表示Unicode字符<br>`/\u{62}/u.test('b')`<br>-使用u修饰符，结合量词使用,识别码点大于0xFFFF的 Unicode 字符，`/𠮷{2}/u.test('𠮷𠮷')` <br>- 预定义模式：`'𠮷𠮷'.match(/[\s\S]/gu).length` => 2 <br><br>3:RegExp.prototype.unicode 属性：判断正则是否设置了`u修饰符`<br>`const r2 = /hello/u; ` => r2.unicode === true <br><br> 3.y修饰符：同`g`相似,全局匹配，区别：多次执行匹配，y修饰符确保匹配必须从剩余的第一个位置开始，g只要剩余字符中存在匹配就可以。<br>: `var s='aa_a'; var r1 = /a+/g;var r2 = /a+/y; r1.exec(s); => aa r1.exec(s); => a, r2.exec(s) => aa,  r2.exec(s) => null, 第二次剩余字符为_a, 不是以a开头的，所以匹配失败`  <br>RegExp.prototype.sticky 属性: `r2.sticky => true, 表示是否设置了y 修饰符` <br><br>4. es5: /abc/ig.source => 返回 正则 abc<br> ES6: /abc/ig.flags => 返回表达式的修饰符 `gi` <br><br>|
| 数值 |新增内容  | 1. 二进制前缀(`ob`, `oB`)与八进制(`0o`,`0O`)表示 => `Number('0b111') => 7;  0b111 == 7 => true` <br><br> 2.`Number.isFinite()`用来检查一个数值是否为有限的,只对数字有效，其他类型均false <br><br>3.Number.isNaN()用来检查一个值是否为NaN,只对数字有效，其他类型均false <br><br>3.`Number.parseInt(), Number.parseFloat()`:移植到Number对象上面，行为完全保持不变，使用方式`Number.parseInt('12.34')` <br><br>4.`Number.isInteger()`:判断一个数值是否为整数<br><br>5.`Number.isInteger()`:用来判断一个数值是否为整数 <br><br>4.`Number.EPSILON`:它表示 1 与大于 1 的最小浮点数之间的差,实际是JS能够表示的最小精度，目的在于浮点数计算不精准，设置一个误差返回，如果误差小于这个值，则表示不存在误差 <br>- `0.1 + 0.2 - 0.3 < Number.EPSILON`: 0.1+0.2 不等于0.3，但是误差小于Number.EPSILON,则认为浮点数相等<br><br>5.`安全整数和 Number.isSafeInteger()`: `Number.MAX_SAFE_INTEGER (最大安全整数)`,和`Number.MIN_SAFE_INTEGER(最小安全整数)` <br><br>6.Math 对象的扩展:<br>- `Math.trunc`:用于去除一个数的小数部分，返回整数部分。非Number会先转Number => `Math.trunc(4.5) => 4; Math.trunc(true) => 1; Math.trunc(undefined) => NaN` <br>-`Math.sign`:判断一个数到底是正数(`+1`)、负数(`-1`)、正零(`0`), 负零(`-0`),其他返回`NaN`,非数值先将其转换为数值。`Math.sign(-5) => -1` <br>- `Math.cbrt()`: 用于计算一个数的立方根,非数字先转换为数字。 => `Math.cbrt(8) => 2`<br>- `Math.clz32()`:将参数转为 `32 位无符号整数`的形式，前面将填补多少个0。 `Math.clz32(1)=> 31;将在前面填补31个0` <br> -`Math.imul`:返回两个数以 32 位带符号整数形式相乘的结果，返回的也是一个 32 位的带符号整数 <br>-`Math.fround`:返回一个数的32位单精度浮点数形式。将64位双精度浮点数转为32位单精度浮点数。如果小数的精度超过24个二进制位，返回值就会不同于原值，否则返回值不变（即与64位双精度值一致）。<br> `Math.fround(2 ** 24 - 1) => 16777215` <br> `Math.fround(0.3) => 丢失精度（0.30000001192092896)` <br>`Math.fround(1.125)=>未丢失进度(1.25)` <br> - `Math.hypot()`: 返回所有参数的平方和的平方根,`Math.hypot(3, 4, 5); => 7.0710678118654755` <br> - `Math.expm1()`: `Math.expm1(x)`返回 `ex - 1`，即M`ath.exp(x) - 1` <br> -`Math.log1p()`:`Math.log1p(x)方法返回1 + x的自然对数，即Math.log(1 + x)` <br>-`Math.log10()`:`Math.log10(x)返回以 10 为底的x的对数。如果x小于 0` <br>`Math.log2()`: `Math.log2(x)返回以 2 为底的x的对数` <br>- 双曲函数方法:`Math.sinh(x),Math.cosh(x) ,Math.tanh(x) ,Math.asinh(x),Math.acosh(x),Math.atanh(x)`|
|函数|新增内容|1.函数参数默认值,析构获取参数.通常情况下，定义了默认值的参数，应该是函数的尾参数。因为这样比较容易看出来，到底省略了哪些参数：`function foo(x, { a, b},y = 1){}` <br><br>2.函数的`length属性`：返回`没有指定默认值`的参数个数,设置了默认值的参数不是尾参数，则后面的参数将不计入length。`function foo(x, { a, b},y = 1, z, d){}; foo.length => 2。`<br><br>3.参数的默认值，函数进行声明初始化时`参数`会形成一个单独的作用域（context）。等到初始化结束，这个作用域就会消失 <br> -`var x = 1;var c = 3;function f(x, y = x, z= c, b=function() { c = 10}) {c = 4; b(); console.log(y, z, c);}f('x'); => x 3 10`, 函数参数有生成了单独作用域，x 等于传入的‘x’, y = 'x', z等于外部定义的c,函数内部的`c=4`调用`b()`之前， b函数执行后，将外部c修改为10。如果函数内的`c=4 改为 var c=4`, 则`b()`无法影响函数内容定义的`c`<br><br>4. `rest参数`：获取函数多余参数,是一个数组。`function(a, ...b) {} => b获取剩余参数，是数组`<br><br>5:严格模式变更：es5函数内部可设置为严格模式，es6规定只要函数参数使用了默认值、解构赋值、或者扩展运算符，那么函数内部就不能显式设定为严格模式，否则会报错<br><br>5.函数的`name`属性， 返回函数name,匿名函数返回空字符串<br><br>6.箭头函数:允许使用“箭头”。<br>- 箭头函数没有自己的this对象,所以也就不能用call()、apply()、bind()这些方法去改变this的指向<br>- 不可以当作构造函数 <br>-不可以使用arguments对象,可以用 rest 参数代替。<br>-不可以使用yield命令，因此箭头函数不能用作 Generator 函数 <br><br>6.不适合使用场景：<br>- 定义在对象的方法，该方法内部不适合使用`this` =>`var a = 10; var obj = { a : 20, b:() => { console.log(this.a)}}; obj.b()` <br> - 需要动态this的时候，也不应使用箭头函数。`var  b = document.getElementById('test'); b.addEventListener('click', () => {  console.log(this)}) => this is window`|
|数组|新增|1. 扩展运算符`...`: br - `console.log(1, ...[2, 3, 4], 5) =>1 2 3 4 5` <br> - 复制数组：`var a = [1,2]; var b = [..a];`<br> -合并数组：`var a=[1,2]; var b= [2,3]; var c =[...a, ...b];` <br>- 与解构赋值结合: `var a =[1,2, 3,4]; var [first, ...rest] = a;`<br>- 字符串变数组:`var a = 'hello'; var arr = [...a];` <br>- 扩展运算符内部调用的是数据结构的 Iterator 接口，因此只要具有 Iterator 接口的对象，都可以使用扩展运算符，比如 Map 结构、获取页面的dom的nodelist  <br><br> 2.`Array.from`:将`类数组`或`可遍历的对象(例如Set和Map)`转为真正的数组 <br> -类数组转数组： `var a = {'0': 1, '1': 2, length: 2}; const b = Array.from(a);` <br>- 可遍历对象(NodeList 对象也可以)：`var a =new Set([1,2]); var c = Array.from(a);` <br><br>3.`Array.of`: 将一组值，转换为数组 <br>- `Array.of(3, 11, 8) => [3,11,8]` <br><br>4.`Array.prototype.copyWithin(target, start = 0, end = this.length)`:在当前数组内部，将指定位置的成员复制到其他位置（会覆盖原有成员），然后返回当前数组。`start，end:如果为负数，从末尾开始计算` <br>- `[1, 2, 3, 4, 5, 6, 7, 8].copyWithin(1, -4, -1)=>// -2相当于5号位，-1相当于8号位 => 1,5,6,7,5,6,7,8`,如果要复制最后一位，则不传递`end`参数就行 <br><br>5.`find()，findIndex()，findLast()，findLastIndex() `: <br>- `[1, 4, -5, -10].find((currentValue, index,arr) => currentValue < 0)`, 返回n小于0第一个, 不存在返回undefined <br>- `[1, 4, -5, -10].findIndex((currentValue, index,arr) => currentValue < 0)`, 返回n小于0第一个, 不存在返回-1 <br>- find, findIndex接收第二个参数，作为绑定为调函数的this对象。`let person = {name: 'zyh', age: 20};[10, 12, 26, 15].find(function(n) {return n>this.age}, person); => 函数不能是箭头，箭头函数this是window`<br><br>6.`fill(filldata, startPosition, endPosition)`: 使用给定的值填充一个数组。 <br>- `['a', 'b', 'c'].fill(7) => [7,7,7]` <br>`[1,2,3,4,5].fill(7,2, 4) => [1,2,7,7,5]` <br><br>7.`entries():对键值对的遍历，keys():对键名的遍历, 和 values():对键值的遍历`: 可用`for ...of进行遍历` <br><br>8.`includes()`:某个数组是否包含给定的值,第二个参数表示搜索的起始位置,负数就从end开始数。`[NaN].includes(NaN) => true`<br><br>9.`flat(num)`:将嵌套的数组“拉平”变成一维数组，num为拉平几维数组，默认1为，设置为3，则可将嵌套三维拉成一维数组,`[1, 2, [3, [4, 5]]].flat(2)=>[1,2,3,4,5]`。 <br>`flatMap()`:flatMap()方法对原数组的每个成员执行一个函数（相当于执行Array.prototype.map()），然后对返回值组成的数组执行flat()方法。该方法返回一个新数组，不改变原数组。<br><br>10.数值空位：`var a = Array(3); // 输出 [,,]`,执行`0 in a;`返回`false`, `o in [undefined, undefined]`返回true|
|Object|对象拓展|1.属性简洁表示:`const a ='x'; const b ={a}; // a简洁表示` <br><br>2.表达式作为属性名称:`const a = 'keyname'; const obj = {[a]: 'value'}` <br><br>3.方法的 `name` 属性:函数有`name`属性，方法也有。`const k ={method: () =>{console.log(z.method.name)}}; // 打印method` <br>-通过`getter、setter`取值的方法name属性不在该方法上，而是在该方法的属性的描述对象的`get`和`set`属性上，返回值会加上`get`和`set`： `const z = {get foo() {}, set foo(x){}}; const descriptor = Object.getOwnPropertyDescriptor(obj, 'foo'); console.log(descriptor.get.name);` // 打印`get foo` <br>- bind方法创造的函数，name属性返回bound加上原函数的名字：`var test=function(){};test.bind().name // 返回 bind test`<br>- Function构造函数创造的函数，name属性返回anonymous： `(new Function()).name // 返回anonymous` - 对象方法是个`Symbol`，name返回`Symbol`值的描述: `const k = Symbol('description'); const obj={[k]: () => {}}; console.log(obj[k].name); // 但因[description]` <br><br>4.属性的可枚举和遍历：<br>-对象的`enumerable`是`可枚举性`，如果为`false`则某些操作会忽略该属性。`for...in,Object.keys(), JSON.Stringfy(), Object.assign()`,他们处理Object自身可枚举的属性，`for...in`还会继承的可枚举的属性。`Object.assign()`是ES6新增的 <br>- 属性的遍历：<br>`for..in,自身和继承的可枚举属性，不含Symbol属性`<br>`Object.keys(obj):返回自身可枚举属性的数组，不含继承，不含Symbol属性`<br>`Object.getOwnPropertyNames(obj)，返回自身所有属性集合，包含继承，包含不可枚举属性，不含Symbol属性`<br>`Object.getOwnPropertySymbols(obj):返回自身所有属性集合，包含继承，包含不可枚举属性，包含Symbol属性`<br>`Reflect.ownKeys(obj):返回自身所有属性，含Symbol,含不可枚举，但不含继承` <br><br>super关键字，指向当前对象的原型对象。`var parent={pkey: 'parent'}; var child={pkey: 'child', cmethod(){console.log(super.pkey);}, cfunc:function(){ console.log('super error, because this is function');}}; Object.setPrototypeOf(child, parent); child.cmethod(); // 打印parent, cfunc不能调用super,因为他是函数，不是方法`<br><br>6.对象的扩展运算符: <br>- 解构赋值的拷贝是浅拷贝:`let obj = { a: { b: 1 } };let obj2={...obj};console.log(obj2.a === obj.a) // true` <br>- 只拷贝对象的属性，不会复制继承原型对象的属性:`let parent={a: 1}; let child={b: 1}; chid.__proto__= parent; let {...c}= child;console.log(c); // 没有a属性，只有b属性`|
|Object | 新增方法|1.Object.is(): 同值相等。`var a =[x]; var b = a; Object.is(a, b); // true` <br><br>2.Object.assign(target, source1,source2):将源对象（source）的所有可枚举属性，复制到目标对象（target）。<br>- 是浅拷贝，只拷贝自身属性，不拷贝继承属性和不可枚举的属性。-<br>同名属性的替换,名称重复，后面的替换前面的- <br>数组处理：`Object.assign([6, 7, 3], [4, 5]) // 输出[4,5,3]`,将数组作为对象处理，`[4,5] => {0:4, 1: 5}`，替换了前者 <br>- 复制getter函数赋值的对象,只取值，不影响赋值：`const source = {x get foo() { return 1 }};const target = {};Object.assign(target, source); target.foo = 20` <br><br>3.`Object.setPrototypeOf()，Object.getPrototypeOf()`:设置/获取一个对象的原型对象（prototype）- `const proto = {parentkey: 'xxx'}; const obj = Object.setPrototypeOf(obj, proto);`<br> - `let proto2 = Object.getPrototypeOf(obj)`  |
|运算符拓展|新增|1.指数运算符`**`:`3**4 // 3*3*3*3等于81` |
|ES6引入类型Symbol|新增的原生数据类型|1.类型Symbol表示独一无二的值：`var a = Symbol('a'); var b = Symbol('a'); // a 不等于b` <br>- Symbol不能用于计算（字符串、number都不行），可调用String转为字符串 <br>- Symbol的参数就是它的描述 <br><br>2. Symbol不会出现在遍历对象的时候（`for...in, for...of, Object.keys()`等）, <br>- 它也不算私有属性，可以通过`Object.getOwnPropertySymbols()`获取对象的所有`Symbol`属性名 <br>-`Reflect.ownKeys()`可以通过该方法返回对象的所有键名，包含`Symbol`类型 <br><br>3.`Symbol.for() 与Symbol.keyFor()`: <br>- `Symbol.for()`:description一样，使用同一个Symbol值。将会被登记在全局环境通过key进行搜索，如果存在，直接返回，不存在new一个。`const a = Symbol.for('same'); const b = Symbol.for('same'); a===b; // true` <br> - `Symbol.keyFor()`:返回一个已登记的 Symbol 类型值的key: `let s1 = Symbol.for("foo");Symbol.keyFor(s1) //foo` <br><br>4.内置的Symbol值: <br>- `Symbol.hasInstance`: 当对象调用`instanceof`运算符时`foo instance Foo`，实际调用的是`Foo[Symbol.hasInstance](foo)`。`class MyClass{ [Symbol.hasInstance](foo) {return foo instanceof Array}}; [1, 2, 3] instanceof new MyClass()  // 内部实际调用的是hasInstance` <br>- `Symbol.isConcatSpreadable`: 表示在`concat`数组时，是否可以展开。数组默认为true, 类数组默认为false。`var a = [1,2];var b=[3,4]; b[Symbol.isConcatSpreadable]=false;a.concat(b, 'c') // 输出[1,2,[3,4], 'c']` <br> -`Symbol.species`:指向`构造函数`，创建衍生对象（基于new的实例获取的值）时，会使用该属性。`class MyArray extends Array {static get [Symbol.species]() {return Array; }}const a = new MyArray(); const b = a.map(x => x); // b类型是Array,不是MyArray` <br>- `Symbol.match`:指向一个`函数`,当执行`str.match(newObj)`是调用。`class MyMatcher {[Symbol.match](string) {return 'hello world'.indexOf(string);}} 'e'.match(new MyMatcher()) // 匹配出index为1 ` <br>- `Symbol.replace`: Symbol.replace方法会收到两个参数，第一个参数是replace方法正在作用的对象。`const x = {};x[Symbol.replace] = (a,b) => console.log(a,b);var a = 'Hello'.replace(xxx, 'World') // 打印出 Hello world` <br> -`Symbol.search`: 指向一个方法。`const x = {};x[Symbol.search] = (a) => console.log('worldHelloWord'.includes(a), a);var a = 'Hello'.search(x)` <br> - `Symbol.split `:重新定义了字符串对象的split方法的行为。`const x = {};x[Symbol.split] = (a) => console.log(a);var a = 'Hello'.split(x)` <br>- `Symbol.iterator`: 指向该对象的默认遍历器方法 <br>- `Symbol.toPrimitive`: 指向一个方法。该对象被转为原始类型的值时，会调用这个方法，返回该对象对应的原始类型值。`et ab = {[Symbol.toPrimitive](hint) {switch (hint) {case 'number': return 123; default:throw new Error();}}}; 3 * ab ; // 等于 3 * 123 = 369` <br>-`Symbol.toStringTag`: 用来设定一个字符串。设定的字符串会出现在toString()方法返回的字符串之中，表示对象的类型。也就是说，这个属性可以用来定制[object Object]或[object Array]中object后面的那个大写字符串。<br>`var s = {}; s.toString();//输出'[object Object]' `<br>`var s = ({[Symbol.toStringTag]: 'Foo'}.toString()); s.toString(); //'[object Foo]' 不是Object是Foo` <br>-`Symbol.unscopables`: 指向一个对象。该对象指定了使用with关键字时，哪些属性会被with环境排除。`with是已过期的语法，这里不探讨`|
|Set与Map|新增|1.`Set`:类似于数组，但是成员是唯一的。可接受具有`iterable接口`的其他数据结构作为参数。<br>- 可以用于数组去重。`[...new Set([1,2,3,2,2])]; // 输出 1,2,3` <br>- 增、删、查、改、长度方法。`const set =new Set([1,2,3,4,5]); set.size; set.add(10).add(100);set.has(10); set.clear();`<br>- 遍历操作：<br>`keys()，values()，entries()`: 因为`Set`没有键名，所以`keys()`和`values()`结果一样,`entries()`返回的`[key,value]`结构也相等<br>`Set.prototype[Symbol.iterator] === Set.prototype.values`:因为`Set`结构默认实例可比案例，且遍历生成器函数就是它的values方法，因此可以直接沈略`values`进行遍历。`const set=new Set([1,2]); for(let v of set){console.log(v)}` <br>`forEach()`:`const set=new Set([1,2]); set.forEach((value, key) => console.log(value))` <br>`交集(new Set([...a].filter(x => b.has(x))))、并集( new Set([...a, ...b]))、差集(new Set([...a].filter(x => !b.has(x))))` <br><br>2.`WeakSet`: 结构与`Set`类似，但是值只能是`Symbol`或者对象。`WeakSet`是弱引用，它存放的对象，如果其他地方没有引用，则垃圾回收机制将回收它，不会考虑`WeakSet`的引用。因为`垃圾回收机制何时运行不可预测，因此WeakSet不可比遍历` -<br> `WeakSet`的方法：`add(),delete(),has()`，没有遍历方法 <br><br>3.`Map`:键值对集合。传统`Object`只能是`字符串`作为`Key`，而`Map`可以是各种类型的值作为`Key`。 <br>- 增删改查方法 `set(),get(), size,has(), delete(),clear()`：`const map=new Map(); map.set('a', 'b'); const obj={}; map.set(obj, 'c'); map.get(obj);map.has('a');map.delete(obj); map.size;map.clear();` <br>-不仅仅是数组，任何具有 Iterator 接口、且每个成员都是一个双元素的数组的数据结构都可以当作Map构造函数的参数。`const map=new Map([['key1', 'value1'], ['key2', 'value2']])` <br>- `key`唯一，后面的值将覆盖前面的 <br>- 遍历方法,Map的遍历顺序就是插入顺序：`keys(), value(), entries(), forEach()`：`for (let [key, value] of map.entries()) {console.log(key, value);}`<br>结合数组的`map，filter`方法可以实现遍历和过滤:`const map = new Map([[1, 'one'],[2, 'two'],[3, 'three']]); map.entries().map(() => {...})` <br>对象转Map: `new Map(Object.entries(obj))`,Map转对象需要遍历处理 <br><br>4.`WeakMap`: 与`Map`结构类似，但是不接收`NULL`作为键名。其键名指向的对象，均不计入垃圾回收机制，因此不具备迭代的功能。典型应用场景：在网页的 DOM 元素上添加数据，就可以使用WeakMap结构。当该 DOM 元素被清除，其所对应的WeakMap记录就会自动被移除 <br>拥有方法：`get(),set(),has(),delete()`|
|Proxy|新增代理|在目标对象之前架设一层“拦截”，外界对该对象的访问，都必须先通过这层拦截，因此提供了一种机制，可以对外界的访问进行过滤和改写。 <br><br>1.创建调用:`const target ={a: 1};const proxy = new Proxy(target, { get: (target, proxyKey)=> {return proxyKey + ': test'}}); proxy.x; // 打印'x:test'，target的值不受影响。`，如果直接修改`prxoy.a = 10; 将直接修改target，因为这里没有设置set方法进行拦截`。 <br><br>2.拦截器支持的方法：<br>- 拦截对象属性的读取`get()`:`const proxy = new Proxy(target, { get: (target, proxyKey)=> {return target[proxyKey]}});` <br>-`set()`:拦截某个属性的赋值操作。`const proxy = new Proxy(target, { set: (target, propKey, value, receiver)=> {target[proxyKey] = value;}});`，目标对象自身的`某个属性`不可写(`writable: false`)，那么set方法将不起作用 <br>- `apply()`:apply方法拦截`函数的调用`、`call`和`apply`操作。三个参数分别是目标对象、目标对象的上下文对象（this）和目标对象的参数数组。`const proxy = new Proxy((a,b)=>{return a + b}, { apply (target, ctx, args) { console.log(Reflect.apply(...arguments) * 2);;}}); proxy.apply(null, [1,2]);// 输出6` <br>- `has()`:拦截`propKey in proxy`的操作，两个参数`目标对象、需查询的属性名`,返回布尔值。`const proxy = new Proxy({a: 1, '_d':2}, { has (target, key) {return  key.includes('_') ? false : (key in target)}}); '_d' in proxy; // false`。原对象不可配置或者禁止扩展，这时`has()`拦截会报错。<br>- construct(): 拦截`new`命令。结果必须返回一个对象。`  const p = new Proxy(function () {}, { construct: function(target, args) {return { value: args[0] * 10 };}});(new p(1)).value` <br>- `deleteProperty()`:拦截`delete`操作。返回`false`表示不能被删除。`const p = new Proxy({_prop: 'test'}, { deleteProperty(target, key) {  if (key.includes('_')) { return false; } else { delete target[key]; return true} }}); delete p._prop; // 删除失败` <br>- `defineProperty (target, key, descriptor)`:拦截了`Object.defineProperty()`操作。<br>- `getOwnPropertyDescriptor(target, propKey)`: 拦截 `Object.getOwnPropertyDescriptor(proxy, propKey)`返回属性的描述对象。<br>- `getPrototypeOf(target)`:拦截`Object.getPrototypeOf(proxy)，Object.prototype.__proto__，Object.prototype.isPrototypeOf()， Reflect.getPrototypeOf()，instanceof`,返回一个对象。 <br>- `isExtensible(target)`: 拦截`Object.isExtensible(proxy)`，返回一个布尔值 <br>- `ownKeys(target)`：拦截`Object.getOwnPropertyNames(proxy)、Object.getOwnPropertySymbols(proxy)、Object.keys(proxy)、for...in`循环，返回一个数组。该方法返回目标对象所有自身的属性的属性名，而`Object.keys()`的返回结果仅包括目标对象自身的可遍历属性(继承、Symbol、不可遍历的属性) <br>- `preventExtensions(target)`：拦截`Object.preventExtensions(proxy)`，返回一个布尔值。只有目标对象不可扩展时（即`Object.isExtensible(proxy)`为`false`），`proxy.preventExtensions`才能返回`true`,否则会报错。`var proxy = new Proxy({}, {preventExtensions: function(target) {Object.preventExtensions(target);return true;}}); Object.preventExtensions(proxy);proxy.n = 10; // 设置失败` <br>- `setPrototypeOf(target, proto)`：拦截`Object.setPrototypeOf(proxy, proto)`，返回一个布尔值。 <br><br> 3.`Proxy.revocable()`：返回可取消的`Proxy`实例。`let {proxy, revoke} = Proxy.revocable(target, handler); proxy.foo = 123;proxy.foo;// 输出123`，再调用` revoke();proxy.foo; // 错误` <br><br>4.`this` 问题: 只要`Proxy`进行代理，那么`代理对象target`内部`this`就指向了`proxy`,`const proxy = new Proxy({ m: function(){ console.log('self', this)}}, {}); // this is proxy handler`|
|Reflect|新增Reflect|1. 目的：<br>- 现在某些方法在`Object`和`Reflect`都存在，未来新方法将只部署在`Refkect`上。<br> - 当前`Object`的方法出现无法定义时会报错，而`Reflect`会返回`false`,更友好 <br>- 让`Object`操作都变成`函数行为`，例如`delete a.x` 变成`Reflect.deleteProperty(obj, name)` <br>-`Reflect`与`Proxy`对象的方法一一对应，只要在`Proxy`的方法，在`Reflect`上就存在 <br><br>2.`Reflect`的静态方法：<br>-`Reflect.get(target, name, receiver)`, 同`Proxy`一样，`getter`函数`this`指向`receiver`: `var a = {x: 1, y:2, get custom() { return this.x + this.y } }; Reflect.get(a, 'x'); Reflect.get(a, 'custom', {x: 10, y: 20}); // 30` <br>- `Reflect.set(target, name, value, receiver)`: `对应setter`方法内部`this`指向`receiver`。`var a = {x: 1, y:2, set custom(value) {this.x = value; } }; var reciever = {x: 0}; Reflect.set(a, 'x', 0);Reflect.set(a, 'custom',12, reciever);`。`Reflect.set`会触发`Proxy.defineProperty`拦截 <br>- `Reflect.has(obj, name)`: 对应`name in obj`的`in`运算符。`let obj = {a: 1}; Reflect.has(obj, 'a');` <br>- `Reflect.deleteProperty(obj, name)`: 对应`delete obj[name]`的`delete`属性。 `let obj = {a: 1}; Reflect.deleteProperty(obj, 'a')` <br>- `Reflect.construct(target, args)`: 等价与`new target('...args')`。 具体用法：`function A(name){this.name = name;} function A(name){this.name = name;} const instance=Reflect.construct(A, ['ZYH'])` <br> - `Reflect.getPrototypeOf(obj)`: 读取对象的`__proto__`属性。` const a = {}; console.log(Reflect.getPrototypeOf(a) === a.__proto__);` <br>- `Reflect.setPrototypeOf(obj, newProto)`: 设置目标对象的原型。`Reflect.setPrototypeOf(myObj, Array.prototype);`|
|Reflect|新增Reflect|1. 目的：<br>- 现在某些方法在`Object`和`Reflect`都存在，未来新方法将只部署在`Refkect`上。<br> - 当前`Object`的方法出现无法定义时会报错，而`Reflect`会返回`false`,更友好 <br>- 让`Object`操作都变成`函数行为`，例如`delete a.x` 变成`Reflect.deleteProperty(obj, name)` <br>-`Reflect`与`Proxy`对象的方法一一对应，只要在`Proxy`的方法，在`Reflect`上就存在 <br><br>2.`Reflect`的静态方法：<br>-`Reflect.get(target, name, receiver)`, 同`Proxy`一样，`getter`函数`this`指向`receiver`: `var a = {x: 1, y:2, get custom() { return this.x + this.y } }; Reflect.get(a, 'x'); Reflect.get(a, 'custom', {x: 10, y: 20}); // 30` <br>- `Reflect.set(target, name, value, receiver)`: `对应setter`方法内部`this`指向`receiver`。`var a = {x: 1, y:2, set custom(value) {this.x = value; } }; var reciever = {x: 0}; Reflect.set(a, 'x', 0);Reflect.set(a, 'custom',12, reciever);`。`Reflect.set`会触发`Proxy.defineProperty`拦截 <br>- `Reflect.has(obj, name)`: 对应`name in obj`的`in`运算符。`let obj = {a: 1}; Reflect.has(obj, 'a');` <br>- `Reflect.deleteProperty(obj, name)`: 对应`delete obj[name]`的`delete`属性。 `let obj = {a: 1}; Reflect.deleteProperty(obj, 'a')` <br>- `Reflect.construct(target, args)`: 等价与`new target('...args')`。 具体用法：`function A(name){this.name = name;} function A(name){this.name = name;} const instance=Reflect.construct(A, ['ZYH'])` <br> - `Reflect.getPrototypeOf(obj)`: 读取对象的`__proto__`属性。` const a = {}; console.log(Reflect.getPrototypeOf(a) === a.__proto__);` <br>- `Reflect.setPrototypeOf(obj, newProto)`: 设置目标对象的原型。`Reflect.setPrototypeOf(myObj, Array.prototype);`|
|Reflect|新增Reflect|1. 目的：<br>- 现在某些方法在`Object`和`Reflect`都存在，未来新方法将只部署在`Refkect`上。<br> - 当前`Object`的方法出现无法定义时会报错，而`Reflect`会返回`false`,更友好 <br>- 让`Object`操作都变成`函数行为`，例如`delete a.x` 变成`Reflect.deleteProperty(obj, name)` <br>-`Reflect`与`Proxy`对象的方法一一对应，只要在`Proxy`的方法，在`Reflect`上就存在 <br><br>2.`Reflect`的静态方法：<br>-`Reflect.get(target, name, receiver)`, 同`Proxy`一样，`getter`函数`this`指向`receiver`: `var a = {x: 1, y:2, get custom() { return this.x + this.y } }; Reflect.get(a, 'x'); Reflect.get(a, 'custom', {x: 10, y: 20}); // 30` <br>- `Reflect.set(target, name, value, receiver)`: `对应setter`方法内部`this`指向`receiver`。`var a = {x: 1, y:2, set custom(value) {this.x = value; } }; var reciever = {x: 0}; Reflect.set(a, 'x', 0);Reflect.set(a, 'custom',12, reciever);`。`Reflect.set`会触发`Proxy.defineProperty`拦截 <br>- `Reflect.has(obj, name)`: 对应`name in obj`的`in`运算符。`let obj = {a: 1}; Reflect.has(obj, 'a');` <br>- `Reflect.deleteProperty(obj, name)`: 对应`delete obj[name]`的`delete`属性。 `let obj = {a: 1}; Reflect.deleteProperty(obj, 'a')` <br>- `Reflect.construct(target, args)`: 等价与`new target('...args')`。 具体用法：`function A(name){this.name = name;} function A(name){this.name = name;} const instance=Reflect.construct(A, ['ZYH'])` <br> - `Reflect.getPrototypeOf(obj)`: 读取对象的`__proto__`属性。` const a = {}; console.log(Reflect.getPrototypeOf(a) === a.__proto__);` <br>- `Reflect.setPrototypeOf(obj, newProto)`: 设置目标对象的原型。`let myObj ={};Reflect.setPrototypeOf(myObj, Array.prototype);`<br>- `Reflect.apply(func, thisArg, args)`: 等价与`Function.prototype.apply.call(func, thisArg, args)`，用于绑定`this`对象后执行给定函数。`const a = Reflect.apply(Math.min, Math, [10,20]);` <br>-`Reflect.defineProperty(target, propertyKey, attributes)`: 等同于`Object.defineProperty`。`function Ojb(){};Reflect.defineProperty(Ojb, 'now', {value: () => Date.now()});` <br>- `Reflect.getOwnPropertyDescriptor(target, propertyKey)`: 基本等同于`Object.getOwnPropertyDescriptor`，用于得到指定属性的描述对象，将来会替代掉后者 <br>- `Reflect.isExtensible (target)`:对应`Object.isExtensible`，返回一个布尔值，表示当前对象是否可扩展 <br>- `Reflect.preventExtensions(target)`: 对应`Object.preventExtensions`方法，用于让一个对象变为不可扩展。<br>- `Reflect.ownKeys (target)`: 返回对象的所有属性，基本等同于`Object.getOwnPropertyNames`与`Object.getOwnPropertySymbols`之和|
|Promise|写进语言标准|异步编程解决方案。有三种状态（`pending`进行中,`fulfilled`已成功,`rejected`已失败），一旦建成就会立即支持，无法取消。调用`resolve()`后如果后面有代码会继续执行，`const promise=new Promise((resolve, reject)=>{console.log('1'); if (true) {resolve('true value');} else {reject(err)}}); promise.then(() => {console.log('2');}, (err) => {}).catch(() =>{}); console.log('3');`,`Promise`新建后立即执行，打印`1 3 2` <br><br>1.`let p = Promise.all([p1,p2,p3])`: 接受一个`Promise`数组作为参数,当`p1,p2,p3`都是`fullfilled`,`p`就是`fullfilled`,只要其中一个`rejected`, `p`的状态就是`rejected`。实例：`const p1 = new Promise((resolve, reject) => {});const p2 = new Promise((resolve, reject) => {throw new Error('错误')}); Promise.all([p1, p2]).catch(e => console.log(e))` <br>- `Promise.race()`: 将多个 `Promise` 实例，包装成一个`新的 Promise` 实例。`const p1 = new Promise((resolve, reject) => {});const p2 = new Promise((resolve, reject) => {}); Promise.race([p1, p2]).catch(e => console.log(e))` <br>- `Promise.resolve()`:将现有对象转为 Promise 对象。`const jsPromise = Promise.resolve($.ajax('/url'))` 等价于`new Promise(resolve => resolve($.ajax('/url'))` <br>- `Promise.reject()`:返回一个新的 `Promise` 实例，该实例的状态为`rejected`。 <br><br>2. 使用`Promise`加载图片。`const loadImg = (path) => {return new Promise((resolve, reject)=> { const img = new Image(); img.onload = resolve; img.onerror= reject; img.src = path;})}`|
|Iterator迭代器与for...of循环|新增|什么是迭代器：一种接口，为不同数据结构提供统一的访问访问机制，使数据成员按照某种顺序排列，ES6中增加新的遍历`for...of`,Iterator接口主要供`for...of`消费。它`首先创建一个指针`，指向数据结构起始位置，`第一次调用指针对象的next`方法，指针指向数据结构第一个成员，`第二次调用指针对象的next()`方法，指针就指向数据结构第二个成员，.....,直到指向`结束位置`。<br><br> 1. 默认Iterator接口：ES6规定，只要一个数据结构具有`Symbol.iterator`属性，就认为是`可遍历的`。例如ES6的`Array, Map, Set,String, TypedArray,函数arguments对象，NodeList对象`,因为`对象`不确定哪个属性先遍历，哪个后遍历，所以没有部署默认迭代器接口。<br>- `let arr= [1,2]; let iter = arr[Symbol.iterator]();iter.next();iter.next();iter.next();` <br>- 为对象添加迭代接口，调用同数组迭代一样。`let obj = { data: [1,2], [Symbol.iterator]() { const self = this; let index = 0; return { next() { return index < self.data.length ? {value: self.data[index++], done: false}: {value: null, done: true}}}}}` <br><br>2.默认会调用`Iterator`接口的场景：`解构赋值`, `扩展运算符`,`yield*`,`for...of`, `Array.from()`,`Promise().all()`,`Promise.race()`,`Map()`, `Set()`... <br><br>3.字符串的 Iterator 接口:`var str="1,233"; var iter=str[Symbol.iterator]();iter.next();` <br><br>3. `for...of`: 可与`break,continue,return`配合使用。`for(var n of x){if (n >10) break; console.log(n);}`|
|Generator|新增的异步变成解决方案|1.`Generator`特性：<br>- `function`关键字与`函数名`之间有一个`星号`。且函数内部使用`yield`表达式，定义不同的`内部状态`。调用时，使用括号执行函数，返回一个指向`内部状态的指针对象`，执行`next()`移动下一个状态。`function* generator() {yield 'hello'; yield 'world'}; var a = generator(); a.next();a.next();` <br>-`yield`表达式：暂停标志,暂停后将`yield`后的表达式值返回，在执行下一个`next`时，返回下一个`yield`后表达式的值。没有则返回`undefined`.<br> -`yield`放在表达式中，需要使用圆括号。`function* demo(){console.log('hello' + (yield 123));}` <br><br>2.与`Iterator`的关系：`Generator`函数就是`遍历器生成函数`，将`Gnerator`赋值给对象的`Symbol.iterator`属性，使其具有`Iterator`接口。`var obj={}; obj[Symbol.iterator]=function*(){yield 1; yield2;};` <br><br>3.`next()`方法参数：`next()`的参数是表示上一个`yield`表达式的返回值。`function * generator(x){var first = (yield (x + 1)) * 2; var second=yield(x + first); var three=yield second+10;} var iter=generator(1); iter.next(); iter.next(6);iter.next(9);`。`next方法`的参数表示上一个yield表达式的返回值,因此第一个`next`参数无效。<br>- 第一次调用`next()`,`x`为`1`，返回`yield(x + 1)`的值`2`。<br>- 第二次`next(6)`:`x`还是为`1`,将上次`yield`的值设置为`6`，计算`first= 6 * 2`则`second= 1 + 12，`,输出`13` <br>- 第三次`next(9)`: 虽然上次输出是`13`，但是`next(9)`的参数是`9`，则`three= 9 + 10`,输出`19` <br><br>4.`for...of, 拓展运算符..., 结构赋值，Array.from`可以将`Generator函数`返回的`iterator`对象作为参数。`function * number(){yield 1; yield 2}; const a = number(); Array.from(a)`<br><br>5.`Generator.prototype.throw()`:Generator 函数返回的遍历器对象，都有一个throw方法，可以在函数体外抛出错误，然后在 Generator 函数体内捕获。`const g = function*(){try {yield 1;}catch(e){console.log('内部catch');}}; try{let iter=g(); iter.next(); iter.throw('g catch');iter.throw('g2 catch')}catch(e){console.log('外部');}`,因为generator只执行一次，因此捕获第一个`throw`,第二个`throw`会被外部捕获。内部捕获不会影响下一次遍历。<br><br>6.`Generator.prototype.return()`: 返回的遍历器对象还有一个`return()`方法，可以返回给定的值，并且`终结`遍历 Generator 函数。`var gener=g(); gener.next();gener.return('custom value'); // 终止遍历并返回value,不提供参数返回undefined` <br><br>7: 总结：`next()、throw()、return()`都是让 Generator 函数恢复执行，并且使用不同的语句替换yield表达式。 假如 `yield`表达是为`function *gener(){let result = yield x + y;return result;}` , 调用第二个`next(10)`,相当于`let result=10;`, 调用`iter.throw(new Error('错误'))`，相当于`let result = throw(new Error('错误'))`,调用`iter.return(30)`,相当于`let result=30; return result;` <br><br>8.`yield* 表达式`: 在一个 Generator 函数里面执行另一个 Generator 函数。`function* f1(){yield 1; yield 2} function * f2() {yield 3;  yield*f1()}; var iter=f2(); [...iter] // [3,2,1]` <br><br>9.可作为对象的属性，`var obj={gener: function*(){}}`。 可通过`call`方法绑定`Generator`函数内部的`this`，`var obj={};function *Gener(){ console.log(this); yield this.a=10;}; var g = Gener.call(obj);// Gener实例内部this绑定obj`,调用` g.next(); obj.a; // 10` <br><br>10.同步流程：`function * task(value){ var value1=yield step1(value); var value2=yield step2(value1)};`,调用第一步：`var iter=task(1); var taskObj=iter.next();`，只要没有`done`,则继续调用`if(!taskObj.done){iter.next(taskObj.value)}`|
|Generator异步编程|新增|1.异步任务封装：`function * gen(url){var result=yield fetch(url);console.log(result);} var g = gen('xxx');var result = g.next(); result.value.then(() => { return data.json}).then((data) =>{g.next(data);})` <br><br>2.`Thunk` :将多参数函数替换成一个只接受回调函数作为参数的单参数函数。`const Thunk=function(fn){return function(...args) {return function(callback){ return fn.call(this, ...args, callback);}}}`, 单参数函数调用`var readFileThunk = Thunk(fs.readFile);readFileThunk(fileA)(callback);`|
|class|新增|1.`class`只是一个语法糖，构造函数的`prototype属性`，在 ES6 的“类”上面继续存在。事实上，类的所有方法都定义在类的`prototype属性`上面,调用类实例方法，实际就是调用原型上的方法，<br>- `class Person{constructor(){} toValue(){}}` 等价于`Person.prototype={constructor(){}, toValue(){}}` <br> - `prototype`的`constructor`指向类本身： `Person.prototype.constructor === Person` <br><br>2.`constructor()`:类的默认方法,`new`生成实例时自动调用 <br><br>3.类实例：`new`关键字生成,`const person1 = new Person(); const person2=new Person()`,同`es5`一样，实例共享原型对象`person1.__proto__ === person2.__proto__`,它们的原型都是`Person.prototype` <br>- `getter`与`setter`：`const propsName="custom"; class P{ _p = ''; get prop(){return this._p; }; set prop(value) { this._p = value + 'hello'} [propsName](){}}` <br> -`Class`表达式：`const MyClass= class Me{}; const Myclss= class {}` <br><br> 3.静态方法：`static`关键字，该方法不会被实例继承，而是直接通过类来调用,静态方法中的`this`指向`类`，不是实例。静态方法会被继承。`class Person{ static _name = 'yezi'; static getName(){console.log(this._name);}} Person.getName();// yezi` <br><br>4.静态属性: Class 本身的属性，即Class.propName，而不是定义在实例对象（this）上的属性。`class P { static classProps1 = 10;} P.classProps2=20;` <br><br>5.注意点：<br>- 不存在变量提升，`name`属性表示`class`关键字后面的类名。<br>- 如果某个方法之前加上星号（`*`），<br>-就表示该方法是一个 Generator 函数,方法内部如果含有`this`，它默认指向类的实例。可用构造方法中`bind`,解决单独使用方法报错问题.`class P{constructor(){this.method1= this.method1.bind(this);} method1() {this.method2()}  method2() {console.log('method2')} method3() {this.method2()}}`,调用时 `const {method1,method3} =new P();method3(); // 内部报错，this执行错误，不存在method2` <br><br>6.`new.target`属性：构造函数如果是通过`new`或`Reglect.construct()`，`new.target`返回`class`的`name`,否则返回`undefined`。`function P(name) {if (new.target) {this.name=name} else {throw new Error('必须使用new命令')}}`，调用`P('hello')// 抛出异常`|
|class的继承|新增|1.`extends`实现继承。因为子类基于父类，因此需先调用`super()`才能使用`this`关键字。`class P{constructor(x,y) {this.x=x;this.y=y;}} class C extend P{ constructor(x,y) {super(x, y);}}` <br><br>2.私有属性与私有方法不能被继承。`class P {#myname='zyh'; #myMehtod() {}} class C extends P { constructor(){super(); this.#myMethod(); // 抛出异常}}` <br><br>3.静态属性与静态方法被继承 <br><br> 4.可通过`Object.getPrototypeOf()`获取父类。`class P{} class C extends P{}  Object.getPrototypeOf(C) === P // true` <br><br>5.`super`关键字：<br>- 当做函数调，代表父类构造函数在子类中调用，但要注意,子类中调用`super`，`this`指向了子类的实例，相当于`P.prototype.constructor.call(this)`。`new.target`执行当前正在执行的函数。`class P{ constructor(){ console.log(this, new.target)}} class C extends P{constructor(){super()}}`,`new C() // this执行C实例，new.target指向C` <br>- `super`作为对象时，在普通方法中，指向`父类的原型对象`，`this`指向`子类实例`；在`静态方法`中，指向`父类`，this指向子类（不是子类实例）。`class P {cName=20; pMethod(){console.log(this.cName);} static PsMehtod(){console.log(20);}} class C extends P { cName=10;constructor(){ super(); super.pMethod(); // 普通方法指向父类原型对象，对然调用父类方法，但实例内部this指向实例，因此打印10} static Cmethod() {super.PsMehtod(); // 指向父类，打印20}}` <br><br>6.子类`__proto__`表示构造函数的继承，总是指向父类，子类`prototype`的`__proto__`属性表示方法的继承，指向`父类的prototype属性`。<br>- `class A{} class B extends A{}`, `B.__proto__ === A // true`， `B.prototype.__proto__ === A.prototype // true`, 其实就是等价于`Object.setPrototypeOf(B.prototype, A.prototype);Object.setPrototypeOf(A, B);`, 而`setPrototypeOf方法内部实现：function(B, A) {B.__proto__ = A;}` <br>- 不存在继承时：`class A{}`, `A.__proto__ === Function.prototype`; `A.prototype.__proto__=Object.prototype`,|
|moudle 模块话|新增|1.ES6模块加载。`import { stat,exists } from 'fs';`,在只会加载这连个方法，不会全部载入，因此可在`编译时加载`,使`静态分析`成为可能。而`CommonJS`模块`let { stat, exists } = require('fs');`,需要进行全量加载，将所有方法加载再读取，因为只有运行时才能得到这个对象，导致无法再编译时做`静态优化`。 <br><br>2.`export`与`import`:希望外部能够读取模块内部的某个变量,使用`export`导出,希望引入外部文件的变量，使用`import`导入。A文件a.js导出：`cons a= 'xx'; export { a }`; B文件导入`import { a } from 'a.js'; `。<br>- 在静态分析阶段，不能使用`表达式、变量、if`等结构。`import { a +b} from 'xx'; if(x==1) {import a from 'a.js'}...`都会出错。<br><br> 3.使用`*`加载整个文件导出的内容。` import * as All from 'a.js';` <br><br>4.使用`export default`命令导出默认变量或函数等。在引入时就不用`{}`了。 `const a = 'hello'; export default a;`，导入：`import A from 'a.js';` <br><br>4.模块的继承和改名：<br>-  继承extendsMoudle中所有方法并导出。`export * from 'extendsModule';` <br> - 改名：`export { a as changeName } from 'extendMoudle';` <br>5.跨模块共享值： A模块：`export const a=10;`, 在X模块引入:`import * as A from 'a.js'; console.log(A.a);`, 在Y模块引入:`import * as A from 'a.js'; console.log(A.a);` ,可达到共享。 |
|Moudle 加载实现|新增|1. JS对脚本静态分析的时候，遇到模块加载命令import，就会生成一个只读引用。等到脚本真正执行时，再根据这个只读引用，到被加载的那个模块里面去取值。加载规则：`type="module"`,js就知道是es6的模块加载。`<script type="module" src="./foo.js"></script>`默认是`defer`属性，可以自己设置为`async`属性，脚本在后台加载完就立即运行。 `<script type="module" src="./foo.js" async></script>`。如果在模块作用域中，模块内部变量对外不可见，默认严格模式，模块中顶层`this`为`undefined`,不是window。可用`this`判断是否在e6模块中。`const isInES6Moudle= this === undefined` <br><br>2.ES6模块与CommonJS模块差别：<br>- CommonJS输出是值的拷贝，外部引入后修改不会影响值的变化。 ES6模块是值的引用 <br>- CommonJs是运行时加载，ES6模块式编译时输出层接口 <br>- CommonJS模块的require()设计同步加载模块，ES6模块的`import`是异步加载，有一个独立的模块依赖的解析阶段 <br><br>3.`Node.js`的模块加载：只要是`.mjs`命名的文件，`Node.js`就认为是`ES6`模块。默认开启严格模式。如果不希望使用`.mjs`，可在`package.json`中配置`{"type": "module"}`。`.cjs`文件总是以 `CommonJS `模块加载。或者配置`package.json`的`{"type": "commonjs"}`|
|Decorator|使用很少，暂时不做详细了解||
|ArrayBuffer|暂时不做详细了解||

tips:<br>:
### 什么是单精度，什么是双精度
单精度浮点数占4字节（32位）内存空间，其数值范围为-3.4E38～3.4E+38,；双精度型占8 个字节（64位）内存空间，其数值范围为-1.79769313486232E308 到1.79769313486232E308。 双精度浮点型类型数值可转换到其他类型的整数或浮点数，反之亦然。

# 2.ES2017
| name | 编写 | 注意点|
| :--- | :--- |--- |
|ES2017 |String| 1.字符串补全长度的功能<br>padStart()，padEnd():<br> - padStart(length, 'str')， padEnd():字符串头部(尾部)补全长度，`'x'.padStart(5, 'ab') => ababx`, 元字符长度大于参数length, 补全不生效，参数str大于length，截断超出的位数，不传入补全str,则使用空格代替，优秀用法：`'09-12'.padStart(10, 'YYYY-MM-DD') => "YYYY-09-12"` |
|函数|新增| 1. 允许函数的最后一个参数有尾逗号 => `function f(param1, param2) 提升 function f(param1, param2,)`|
|Object | 新增方法|1.Object.getOwnPropertyDescriptors()：返回指定对象所有自身属性（非继承属性）的描述对象 <br>- 浅拷贝实现，以obj为原型，并将obj所有属性copy：`Object.create(Object.getPrototypeOf(obj),Object.getOwnPropertyDescriptors(obj))`<br><br>3.Object.keys()，Object.values()，Object.entries()<br>- `Object.keys():返回自身所有可遍历的所有属性键名数组，不含继承的`<br>-`Object.values()`:返回自身所有可遍历的所有value数组，不含继承的`<br>-`Object.entries()`: 成员是参数对象自身的（不含继承的）所有可遍历（enumerable）属性的键值对数组` <br><br>-`Object.fromEntries()`: 是`Object.entries`的逆向操作，将一个键值对数组转为对象 =>`Object.fromEntries([['foo', 'bar'],['baz', 42]])`|
|aysnc函数|新增|1.`async函数`就是将` Generator 函数`的星号`（*）`替换成`async`，将`yield`替换成`await`，`Generator` ,就是`Generator`函数的语法糖。`async`函数返回`Promise`对象，可在`then`方法添加回调函数。当函数执行时遇到`await`,会先返回，知道异步操作 完成再执行后面的语句。 <br>- sleep 实现： `function sleep(time) { return new Promise((resolve, reject) => { setTimeout(resolve, time);}) }; for(let i = 1; i <= 5; i++) {console.log(i); await sleep(1000); }` <br> - 为了防止`Promise`结果是`rejected`,最好把`await`放在`try..catch`中 <br> - 多个请求如果不是同步关系,让他们同时触发：`let [foo, bar] = await Promise.all([getFoo(), getBar()]);` <br>- `async 函数`的实现原理，就是将 `Generator 函数`和`自动执行器`包装在一个函数里。|
# 3. ES2018
| name | 编写 | 注意点|
| :--- | :--- |--- |
|ES2018 RegExp|新增方法|1. s 修饰符：dotAll 模式 <br> - 正则的(`.`)匹配任意单个特殊字符，但是无法匹配4字节的`UTF-16`字符和行终止符（`U+000A 换行符（\n）, U+000D 回车符（\r）,U+2028 行分隔符，U+2029 段分隔符`）， <br>`/foo.test/.test('foo\ntest') => false` <br>`/foo.test/s.test('foo\ntest') => true` <br> - dotAll属性: `const reg = /a.b/s`; `reg.dotAll => true; reg.flags => s` <br><br> 2.后行断言(`?<=`, `?<!`):<br>- `/(?<=y)x/`: 匹配前面是`x`的`x`,`"yxdsdsdxx".match(/(?<=x)x/)` => index为8的x<br>- `/(?<=\$)\d+/`: 匹配在美元符号后的数字`'x$1xx$10xd$x'.match(/(?<=\$)\d+/)` - 匹配前面不是`x`的`x`, `"yxdsdsdxx".match(/(?<!x)x/)` => index为1的x <br><br>3.\p{...}和\P{...}（\P是\p的否定形式）代表一类 Unicode 字符，匹配满足条件的所有字符<br> -`var reg =/\p{Script=Greek}/u; reg.test('π')` => true: 匹配一个希腊文字母 <br> -`var reg = /^\p{Decimal_Number}+$/u; reg.test('𝟏𝟐𝟑𝟜𝟝𝟞𝟩𝟪𝟫𝟬𝟭𝟮𝟯𝟺𝟻𝟼')`=> true,匹配各种字形的十进制字符 <br> `var reg =  /^\p{Number}+$/u; reg.test('¹¼½ⅤⅥⅦⅧⅨⅩ㉛㉜')` => true,匹配数字，甚至能匹配罗马数字 <br> -`\p{White_Space}`: 匹配所有空格<br>- `\p{Hex_Digit}`:匹配十六进制字符 <br>- `/\p{Extended_Pictographic}/u`: 匹配 Emoji <br><br>2. 具名组匹配：允许为每一个组匹配指定一个名字，既便于阅读代码，又便于引用 <br> -`const RE_DATE = /(?<year>\d{4})-(?<month>\d{2})-(?<day>\d{2})/;const reg = RE_DATE.exec('1999-12-31'); const { year, month, day} = reg.groups`<br>- 利用解构赋值，替换正则:`('1999-12-31').replace(RE_DATE, '$<day>/$<month>/$<year>')` => '31/12/1999' <br> 正则表达式内引用`具名组匹配`使用`\k<组名>`, `\1`：`/^(?<year>\d{4})-\k<year>-\1$/.test('1990-1990-1990')` => true|
|Function|修改|1. 函数实例的toString()：返回一模一样的原始代码。`var f =(a, b) => {console.log(a, b);} f.f.toString(); 打印内容'(a, b) => {console.log(a, b);}'`|
|Promise|新增|1.`Promise.prototype.finally()`: 不管 Promise 对象最后状态如何，都会执行的操作|
|异步遍历器 async-iterator|新增|1.调用遍历器的next方法，返回的是一个 Promise 对象，在`then`的回调函数中，则是一个具有`value,done`两个属性的对象。`asyncIterable.next().then(({value, done}) => {})`。<br>- 异步调用。`const iteratorble = createAsyncIterable(['a', 'b']); const iter=iteratorble[Symbol.asyncIterator]();const [{value: v1}, {value: v2}]=await Promise.all([iter.next(), iter.next()])` <br><br>2.`for await ...of`: 遍历异步的 Iterator 接口。也可用于同步遍历，和`for..of`效果一样。<br>- req：异步读取数据，当异步reject会报错，使用`try..catch`,`try {for await(const data of req){ body += data;}}catch(e){}` <br><br>3.`异步Generator`函数：`async函数`与 `Generator 函数`的结合。`async function * aysncGenerator() { const result = await fetch('url'); yield await result.text(); }` ,调用遍历器：`var gener=aysncGenerator(); gener.next().then((value, done)=> {})` <br><br>4.`yield*`: 也可以跟一个异步遍历器。`async function * gen1() {yield 'a'; yield 'b';} for await(const x of gen1()) { console.log(x);}`|

# 4 .ES2019
| name | 编写 | 注意点|
| :--- | :--- |--- |
| ES2019  |String |1. 消除空格：对字符串头部（或尾部）的 tab 键、换行符等不可见的空白符号也有效<br>trimStart(): 消除字符串头部的空格,<br>trimEnd():消除字符串尾部部的空格|
|Function|修改|try catch 可省略`err`。之前`try{}catch(err){}`, 现在`try{}catch{}`|
|ES6引入类型Symbol|新增|1.新增`description`属性，返回描述值:`const s = Symbol('desc'); s.description // desc`|

# 4 .ES2020
| name | 编写 | 注意点|
| :--- | :--- |--- |
| ES2020  |RegExp |1. `String.prototype.matchAll()`一次取出所有匹配，返回迭代器<br>`const string = 'test1test2test3';const regex = /t(e)(st(\d?))/g;for (const match of string.matchAll(regex)) {console.log(match);}`|
| ES2020  |Number | 1. BigInt 只用来表示整数，没有位数的限制，任何位数的整数都可以精确表示, 数据必须添加后缀`n`。`typeof 123n => bigint`，有正负号`-42n`。<br>- `let a = 1234n` <br> - 可以使用各种进制表示，都要加上后缀n ,`let a= 0o777n;`<br> - BigInt 函数: `let a = new BigInt(192);`<br>- 其他方法：`BigInt.asUintN(width, BigInt),BigInt.asIntN(width, BigInt), BigInt.parseInt(string[, radix])` |
|ES2020运算符拓展|新增|1.链判断运算符`?.`，判断左侧是否是undefined或者null:`const obj = message?.body?.content;`,可用于`obj?.prop`属性、`obj?.[expr]`属性、 `func?.(...args)`函数或方法 <br>2.Null 判断运算符`??`,只有运算符左侧的值为null或undefined时，才会返回右侧的值，与\|\|的区别：它只检查null或undefined，\|\|只要左侧是`假值`都会返回右边。例如 `NaN \|\| 'hello'` => 返回hello, `NaN ?? 'hello'` => 返回NaN |
|Promise|新增|1.`Promise.allSettled()`: 等到一组异步操作都结束了，不管每一个操作是成功还是失败，再进行下一步操作。`Promise.all()`只适合所有异步都成功的情况，无法满足一个失败继续执行的。`Promise.allSettled()`数组的每个成员都是一个 Promise 对象，并返回一个新的 Promise 对象。只有等到参数数组的所有 Promise 对象都发生状态变更（不管是fulfilled还是rejected），返回的 Promise 对象才会发生状态变更。|
|module|新增|1.导出方法: `export * as ns from 'mod';`等价与`import * as ns from 'mod'; export ns;` <br><br>2.`import()`函数:`import`和`export`命令只能在模块的顶层，不能在代码块之中（比如，在if代码块之中，或在函数之中）。而引入`import()`函数支持动态加载模块，返回`Promise`对象。`button.addEventListener('click', () => {import('./x.js').then(...); }])`,任何地方可调用，`if`条件表达式，动态模块加载地方等都可以调用。<br><br>3.`import.meta`:返回当前模块的元信息。只能在模块内部调用。`import.meta.url`：当前模块的 URL 路径。`import.meta.scriptElement`: 是浏览器特有的元属性，返回加载模块的那个`<script>`元素，相当于`document.currentScript`属性|
# 4 .ES2021
| name | 编写 | 注意点|
| :--- | :--- |--- |
| 数值 |新增内容  | 1. 允许每三位添加一个分隔符(`_`),不能放在数值最前或最后，分隔符不能多个链接，小数点后不能有分隔符，科学计数法`e`前后不能有分隔符:<br>`let num = 1_000_000; num === 10 ** 6; => true` <br> 小数可使用：`let a = 0.022_122;`<br> 科学计数法：`let a = 1e10_000` |
|对象|新增内容|1.AggregateError错误对象：AggregateError 在一个错误对象里面，封装了多个错误。如果某个单一操作，同时引发了多个错误，需要同时抛出这些错误，那么就可以抛出一个 AggregateError 错误对象，把各种错误都放在这个对象里面|
|ES2021运算符拓展|新增|1.新增三个逻辑运算符：<br>- 新增 `\|\|=,`: `x \|\|= y`： 等价`x \|\| (x=y)` <br>-新增`&&=`: `x&&=y`等价`x && (x=y)` <br>-新增`??=`: `x??=y`等价`x ?? (x=y)` <br>-用处，为遍历设置默认属性：`user.id \|\|=1` |
|Set和Map|新增|1，`WeakRef`：用于直接创建对象的弱引用。WeakRef 实例对象有一个deref()方法，如果原始对象存在，该方法返回原始对象；如果原始对象已经被垃圾回收机制清除，该方法返回undefined。`let target = {}; let wr = new WeakRef(target); let obj= wr.deref(); if (obj){} // obj存在，target 未被垃圾回收机制清除`。标准规定，一旦使用WeakRef()创建了原始对象的弱引用，那么在本轮事件循环（event loop），原始对象肯定不会被清除，只会在后面的事件循环才会被清除 <br><br>2.清理器注册表功能`FinalizationRegistry`:用来指定目标对象被垃圾回收机制清除以后，所要执行的回调函数。<br>- 实例化：本身有一个参数heldValue: `const registry = new FinalizationRegistry(heldValue => {});` <br>- 注册所要观察的目标对象,参数一，要观察的对象，一旦该对象被垃圾回收机制清除，注册表就会在清除完成后，调用早前注册的回调函数，并将 `some value`作为参数（前面的`heldValue`）传入回调函数:`registry.register(theObject, "some value",theObject);` <br>- 参数3：必须是对象，一般都用原始对象。接着，再使用注册表实例对象的unregister()方法取消注册。`registry.unregister(theObject);`|
|Promise|新增|1.`Promise.any([p1,p2,p3])`:参数数组包含三个 Promise 操作。其中只要有一个变成`fulfilled`，返回的 `Promise` 对象就变成`fulfilled`。如果所有三个操作都变成`rejected`就会抛出错误|

# 5 .ES2022
| name | 编写 | 注意点|
| :--- | :--- |--- |
| ES2022 RegExp|新增 |1. `d 修饰符`：正则匹配索引,exec()、match()的返回结果添加indices属性，在该属性上面可以拿到匹配的开始位置和结束位置<br>- `const text = 'zabbcdef';const re = /ab+(cd(ef))/d;const result = re.exec(text);` => `result.indices // [ [1, 8], [4, 8], [6, 8] ]`, 匹配出ef, cdef, abcdef 三组index|
|数组|新增|1.`findLast()和findLastIndex()`：同`find和findIndex`一样，只不过从最后一个成员依次往前检查<br><br> 2. `at(index)`: 返回索引位置的值，支持负索引。|
|对象|新增内容|1.Error 对象的 cause 属性,可以在生成错误时，添加报错原因的描述：`const actual = new Error('an error!', { cause: 'Error cause' });` <br><br>2.`Object.hasOwn()`: javascript属性分为自身属性和继承属性，该方法用于判断是否是自身属性,`const foo = Object.create({ a: 123 }); Object.hasOwn(foo, 'a') // a是继承属性` |
|async 函数|update|1.早期的语法规定是await命令只能出现在 `async 函数内部`，否则都会报错,现在允许在模块的顶层独立使用await命令，使得上面那行代码不会报错了。它的主要目的是使用await解决模块异步加载的问题，注意`顶层await`只能用在 ES6 模块。`const strings = await import('/i18n/${navigator.language}');`|
|class属性的新写法|新增|之前定义在constructor()方法里面的this上面:`class P{constructor(){this.x=10}}`; 现在可写在最顶层：`class P{_x = 10; constructor(){}}`|
|class|新增或修改|1.添加了私有属性，方法是在属性名之前使用`#`表示:`class P { #props=10; get p(){return this.#props;}} const p = new P(); p.p;// 10 `,但是`p.#props`报错 (注意，从 Chrome 111 开始，开发者工具里面可以读写私有属性，不会报错，原因是 Chrome 团队认为这样方便调试。),私有属性也可以有`getter和setter`方法，也可以加`static`关键字。 <br><br>2.改进了in运算符，使它也可以用来判断私有属性。`class P {#a=10; static isA(o) { return #brand in o; }} var a = new P(); P.isA(a);` <br><br>3.`静态块（static block`:允许在类的内部设置一个代码块，在类生成时运行且只运行一次，主要作用是对静态属性进行初始化。允许有多个静态块，每个静态块中只能访问之前声明的静态属性。另外，静态块的内部不能有return语句。`class P { static a=10; static { // 只执行一次的初始化内容}}`|
# 5 .ES2023
| name | 编写 | 注意点|
| :--- | :--- |--- |
|数组|新增|1.`toReversed()-对应reverse()，颠倒数组成员的位置，toSorted()-对应sort()，对数组成员排序，toSpliced()-对应splice()，在指定位置，删除指定数量的成员，并插入新成员，with()：对应splice(index, 1, value)，用来将指定位置的成员替换为新的值`: 他们对数组进行操作时，均不改变原数组，而返回一个原数组的拷贝|
|运算符的拓展|新增|1.`#!命令`:写在脚本文件或者模块文件的第一行，Unix 命令行就可以直接执行脚本，JavaScript将忽略 这一行 <br>- 文件`hello.js`第一行`#!/usr/bin/env node` ，命令行输入：`./hello.js`|

# 3. ES2024
| name | 编写 | 注意点|
| :--- | :--- |--- |
|ES2024 | RegExp | 1. `v 修饰符`：Unicode 属性类的运算 <br> 1.`[A--B]`: 差集运算（A 减去 B）。`[\p{Decimal_Number}--[0-9]]` 或者 `[\p{Emoji}--\p{ASCII}]`, : 十进制字符去除 ASCII 码的0到9 <br> - `/[\p{Decimal_Number}]/u.test('0') => true`, `/[\p{Decimal_Number}--[0-9]]/v.test('0') => false, 因此排除了十进制的数` <br><br>2.`[A&&B]`:交集运算（A 与 B 的交集）<br> - `var reg = /[\p{Emoji}&&\p{ASCII}]/u; reg.test(':-)123213') => true` |

# 3. ES2025
| name | 编写 | 注意点|
| :--- | :--- |--- |
|Set 与Map|新增|1.新增Set集合运算方法:交集`intersection(other)`，并集`union(other)`,差集`difference(other)`,对称差集——返回两个集合的所有独一无二成员的集合返回两个集合的所有独一无二成员的集合`symmetricDifference(other)`,是否为子集——任何集合都是自身的子集`isSubsetOf(other)`,是否为超集——表示第一个集合是否为第二个集合的超集，即第二个集合的所有成员都是第一个集合的成员`isSupersetOf(other)`, 是否不相交——判断两个集合是否不相交，即没有共同成员`isDisjointFrom(other)`|

# 4.提案
| name | 编写 | 注意点|
| :--- | :--- |--- |
|数组|提案|1.group()，groupToMap(): 将数组按照一定规则进行分组，就行SQL一样。`const array = [1, 2, 3, 4, 5];array.group((num, index, array) => return num % 2 === 0 ? 'even': 'odd';);`, `groupToMap()`作用一样，只是返回的是`Map`结构数据。|
| Promise| 提案| 1.`Promise.try`:为所有操作提供了统一的处理机制，不论是同步还是异步方法，只要想用then方法管理流程，最好都用Promise.try包装一下|
## 2. for循环神奇的点
for循环`(let i = 0; i < 10; i++)`与for循环内部代码块的作用域是单独的：
```javascript
for(let j = 0; j < 10; j++) {
  let j = 'single area';
  console.log(j) // 将打印10次signle area, 并不是 0,1,2,3,4,5,6,7,8,9
}
```
# 相关地址

- [TC39 官方 Github](https://github.com/tc39)
- [最新最全的 ES 官方文档](https://tc39.es/ecma262/)
- [ES 当前的所有提案: github](https://github.com/tc39/ecma262)
- [阮一峰 ECMAScript6 简介](https://es6.ruanyifeng.com/#docs/intro)
- [ES7~ES13](https://esnext-book.lishuaishuai.com/)

https://juejin.cn/post/7282994349444857893

https://juejin.cn/post/7137864230715752485
